[{"title":"'Vue旅行小账本（二）'","date":"2018-10-03T06:34:27.000Z","path":"2018/10/03/Vue旅行小账本（二）/","text":"Vue旅行小账本闲来无事，学习了一段时间的Vue，顺带着把axios vuex vue-router也整体走了一遍，但是一直苦于没有合适的练手项目，直到最近看到微信小程序版的旅行小账本，才发现这个项目才是我一直寻找的。话不多说，直接进入主题。 前期准备，首先大体上看了一遍小程序版的旅行小账本的页面和基本交互，大致确定了技术方案因为页面结构简单，所以没有使用vue的ui库，选取了vue-cli进行开发，vue-cli进行rem适配和其他的一些细节，这里我就不再多讲了，大家有兴趣可以看我另一篇博文。Vue将px转化为rem在数据获取方面，选取了很火的axios，因为没有后台程序，所以数据接口暂时用easy-mock来进行模拟，数据的存储，没有后台接口可用，暂时使用vuex进行存储。 首页首先从vuex中获取需要展示的旅行列表，12345678910111213_getData() &#123; let self = this; if (!self.$store.state.appIndex.travelList.length) &#123; self.noData = true; setTimeout(function() &#123; self.noData = false; &#125;, 3000) &#125; else &#123; self.travelList = self.$store.state.appIndex.travelList; self.noData = false; &#125;&#125;, vuex中的配置，这里我采用了把用户数据保存在localStorage中，不过现在还没有进行优化，这里其实可以把localStorage设置为有时效的，设置一段日期让localStorage清除掉，而不是永久保存。（后期优化点）1234567891011121314151617181920212223242526272829303132333435import &#123; Local &#125; from &apos;../../utils/storage&apos;import uuid from &apos;../../utils/utils&apos;const appIndex = &#123; state: &#123; travelList:(function()&#123; var travelList; if(Local.get(&apos;TRAVEL_LIST&apos;))&#123; travelList = Local.get(&apos;TRAVEL_LIST&apos;); &#125;else&#123; travelList =[]; &#125; return travelList &#125;)() &#125;, actions: &#123; getTravelInfo (&#123;commit&#125;,params) &#123; commit(&apos;GET_TRAVEL_INFO&apos;,params); &#125;, saveTravelInfo(&#123;commit&#125;,params)&#123; commit(&apos;SAVE_TRAVEL_INFO&apos;,params) &#125; &#125;, mutations: &#123; GET_TRAVEL_INFO (state) &#123; Local.get(&apos;TRAVEL_LIST&apos;)?state.travelList=state.travelList.push(Local.get(&apos;TRAVEL_LIST&apos;)):state.travelList=[]; &#125;, SAVE_TRAVEL_INFO(state,travelObj)&#123; travelObj.travelId=uuid(12,16); state.travelList.push(travelObj); Local.set(&apos;TRAVEL_LIST&apos;,state.travelList); &#125; &#125;&#125;export default appIndex 用户点击添加旅行笔记 在进入到添加页面时，我们需要选图，选取背景图片，在这里是后台配置好的背景选择图片，在这里展示给用户，让用户进行选择，如果用户不选择，那么用默认图片替代，这里用户选择完毕的数据可以存储到vuex中，共享给其他页面使用，从而解决了页面之间传递数据的问题。 然后输入需要录入的笔记，进行旅游活动的描述 最后添加到vuex中的travelList中，根据数据的变化来动态地更新页面，在这里有一个点，是使用swiper时，设置 observer，自动初始化swiper1234567891011swiperFun() &#123; let self = this; let swiper = new Swiper(&apos;.swiper-container&apos;, &#123; direction: &apos;horizontal&apos;, slidesPerView: &quot;auto&quot;, centeredSlides: true, spaceBetween: 20, observer: true, //修改swiper自己或子元素时，自动初始化swiper observeParents: true //修改swiper的父元素时，自动初始化swiper &#125;); &#125;,","tags":[]},{"title":"Vue旅行小账本 （一）","date":"2018-09-25T08:55:08.000Z","path":"2018/09/25/Vue旅行小账本（一）/","text":"Vue旅行小账本闲来无事，学习了一段时间的Vue，顺带着把axios vuex vue-router也整体走了一遍，但是一直苦于没有合适的练手项目，直到最近看到微信小程序版的旅行小账本，才发现这个项目才是我一直寻找的。话不多说，直接进入主题。 前期准备，首先大体上看了一遍小程序版的旅行小账本的页面和基本交互，大致确定了技术方案因为页面结构简单，所以没有使用vue的ui库，选取了vue-cli进行开发，vue-cli进行rem适配和其他的一些细节，这里我就不再多讲了，大家有兴趣可以看我另一篇博文。Vue将px转化为rem在数据获取方面，选取了很火的axios，因为没有后台程序，所以数据接口暂时用easy-mock来进行模拟，数据的存储，没有后台接口可用，暂时使用vuex进行存储。 easy-mock进行数据模拟 easy-mock可用很简单地模拟和管理接口非常方便，就拿我们的启动页来说吧 我这里的大致方案是，在路由里进行配置，当项目初始化时，进入启动页面，再由启动页面设置定时器，到时间跳转到首页，下面是具体方案和优化 页面路由的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Vue from 'vue'import Router from 'vue-router'const Index = resolve =&gt; require(['view/index/index'], resolve)const startUp = resolve =&gt; require(['view/start-up/start-up'], resolve)const addTravelInfo = resolve =&gt; require(['view/add-travel-info/add-travel-info'], resolve)const chioceTravelBg = resolve =&gt; require(['view/chioce-travel-bg/chioce-travel-bg'], resolve)const travelInfo = resolve =&gt; require(['view/travel-info/travel-info'], resolve)const travelPayInfo = resolve =&gt; require(['view/travel-pay-info/travel-pay-info'], resolve)Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', redirect: '/startUp' &#125;, &#123; path: '/startUp', // 启动页面只显示5秒 name: 'startUp', component: startUp &#125;, &#123; path: '/Index', // 首页入口 name: 'Index', component: Index &#125;, &#123; path: '/addTravelInfo', // 添加旅行账单页面 name: 'addTravelInfo', component: addTravelInfo &#125;, &#123; path: '/chioceTravelBg', // 选择背景图片 name:'chioceTravelBg', component: chioceTravelBg &#125;, &#123; path:'/travelInfo/:id', //详情页面 name:'travelInfo', component:travelInfo &#125;, &#123; path:'/travelPayInfo', //新增开支页面 name:'travelPayInfo', component:travelPayInfo &#125; ]&#125;) 在进入页面时我们需要进行数据的获取，使用axios进行了简单的封装，获取easy mock的接口数据，这里只是一个简单的数据获取与展示，easy mock的本质就是随机的数据，刚好页面启动页每次需要获取的数据都是随机的，所以使用起来很方便。下面这里是easy mock数据格式的写法，模拟随机返回一个对象123456789101112131415161718192021222324252627282930313233343536&#123; \"data\": &#123; 'status': 200, 'image|1': [&#123; 'imgUrl': 'static/start-up-1.jpg', 'imgAlt': '悬崖大海', 'imgAuthor': '学涯' &#125;, &#123; 'imgUrl': 'static/start-up-2.jpg', 'imgAlt': '远方的旅行', 'imgAuthor': '桃花' &#125;, &#123; 'imgUrl': 'static/start-up-3.jpg', 'imgAlt': '朦胧乡村', 'imgAuthor': '季青' &#125;, &#123; 'imgUrl': 'static/start-up-4.jpg', 'imgAlt': '心中的旅行', 'imgAuthor': '薛慧' &#125;, &#123; 'imgUrl': 'static/start-up-5.jpg', 'imgAlt': '心中的孤岛', 'imgAuthor': '忘记' &#125;, &#123; 'imgUrl': 'static/start-up-6.jpg', 'imgAlt': '宁静的古堡', 'imgAuthor': '凌燕' &#125; ] &#125;&#125; ###优化接口数据渲染方面进行了基本的优化，easy mock的数据请求速度比较慢，很容易由于页面在渲染时图片链接暂时没有，导致图片盒子在页面上有一条边框，不是很美观，所以这里进行了判断，如果链接请求不回来的话，不让img标签显示。 启动页面跳转到首页，前期也是由于，考虑到请求接口时，网络状况不太好，如果一进入页面就执行定时器，那么很有可能，页面上的图片还没加载出来，就直接跳转到了首页，所以我们这里进行了优化处理，当数据请求成功以后，再执行定时器。 最终显示的页面效果","tags":[{"name":"Vue axios vuex vue-router","slug":"Vue-axios-vuex-vue-router","permalink":"http://yoursite.com/tags/Vue-axios-vuex-vue-router/"}]},{"title":"Vuex","date":"2018-09-20T03:39:58.000Z","path":"2018/09/20/Vuex/","text":"要想使用Vuex，我们必须先要明白Vuex是用来干嘛的，这里是官方给出的一个解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。也就是说Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。 Vuex组成1、state 用来存储数据和数据共享2、mutation 用来注册改变数据状态（不能进行异步操作）3、getters 用来对共享数据进行过滤操作4、action 解决异步改变共享数据 Tips1、this.$store ： 我们可以通过 this.$store 在vue的组件中获取vuex的实例。 2、State ： vuex中的数据源，我们可以通过 this.$store.state 获取我们在vuex中声明的全局变量的值。 3、Getter： 相当于vue中的computed ， 及计算属性， 可以用于监听、计算 state中的值的变化 4、Mutation： vuex中去操作数据的方法 （只能同步执行） 5、Action： 用来操作 Mutation 的动作 ， 他不能直接去操作数据源，但可以把mutation变为异步的 6、Module： 模块化，当你的应用足够大的时候，你可以把你的vuex分成多个子模块 Vuex的基本思想 vue的视图都是由数据驱动的，也就是说状态(state)里面的数据是动态变化的，而要改变状态内数据的唯一的方法就是通过mutation!也就是说mutation内可以存放一些改变状态的逻辑方法！这也是Vuex设计的一个特点，处理数据的逻辑和视图进行分离！ 在项目中的使用首先我们新建一个文件夹用来存放vuex的所有文件然后新建一个index.js文件，用来引用和声明vuex，这里我使用modules进行模块化的引入和管理，便于后期代码维护，我们我们在代码中分别注册了，state、getters、mutations、actions。这样我们就可以在任何一个 component中通过 this.$store.dispatch(‘getArticle’, {id: this.$route.params.id})来进行操作然后是getters.js,Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 使用模块式引入不同页面的状态，可以方便后期的代码维护，以用户登录为例，我们建立user.js,然后通过mutation进行模块化管理，在user.js进行我们用户状态的管理。 这里我们可以使用mapGetters将getter 映射到局部计算属性：","tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"JS节流防抖函数","date":"2018-09-19T02:41:12.000Z","path":"2018/09/19/JS节流防抖函数/","text":"JS节流防抖函数JS节流防抖函数我们在很多场景都会用到，例如：在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验特别差。这里我们就可以采用debounce（防抖）和throttle（节流）的方式来减少函数调用频率，从而提升用户体验。 html中的代码123456789101112131415161718192021222324&lt;div id=&quot;content&quot; style=&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;&gt;&lt;/div&gt;&lt;script&gt; var num = 1; var content = document.getElementById(&apos;content&apos;); function handle() &#123; content.innerHTML = num++; &#125;; function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;; window.addEventListener(&apos;scroll&apos;, debounce(handle, 1000));&lt;/script&gt; 在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下可以明显地看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。 防抖函数防抖函数（debounce）：当持续多次触发事件时，约定一定时间段内如果没有再次触发事件，那么事件处理函数才会执行一次，如果在设定时间到来之前，用户又一次触发了事件，那么就重新开始计时。如下图，当持续触发scroll事件时，并不马上执行handle函数，当1000毫秒内没有再次触发scroll事件时，才会延时触发scroll事件。 我们可以来实现一个简单防抖 1234567891011121314function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 这里防抖还可以分为两种：‘立即执行防抖函数’和‘非立即执行防抖函数’ 1、立即执行防抖函数 立即执行的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。1234567891011121314151617function debounce(func,wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 效果如下 2、非立即执行防抖函数 非立即执行的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 1234567891011121314function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 先看看效果 可以看到，在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1 秒内又触发了事件，则会重新计算函数执行时间。 上述防抖函数的代码还需要注意的是 this 和 参数的传递12var context = this;var args = arguments; 防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。 在实际开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。 12345678910111213141516171819202122232425262728/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */function debounce(func,wait,immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 节流函数节流函数（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。 函数节流主要有两种实现方法：时间戳和定时器。 节流throttle代码（时间戳）：12345678910111213function throttle(func, wait) &#123; var previous = 0; return function() &#123; var now = Date.now(); var context = this; var args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 效果是这样的 可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。节流throttle代码（定时器）: 123456789101112131415function throttle(func, wait) &#123; var timeout; return function() &#123; var context = this; var args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 使用方式同上，效果如下 可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。同样地，我们也可以将时间戳版和定时器版的节流函数结合起来，得到最终版节流函数。12345678910111213141516171819202122232425262728293031323334/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */function throttle(func, wait ,type) &#123; if(type===1)&#123; var previous = 0; &#125;else if(type===2)&#123; var timeout; &#125; return function() &#123; var context = this; var args = arguments; if(type===1)&#123; var now = Date.now(); if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;else if(type===2)&#123; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125; &#125;&#125;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Vue:将px转化为rem","date":"2018-08-15T04:31:03.000Z","path":"2018/08/15/Vue-将px转化为rem/","text":"Vue:将px转化为rem1、下载lib-flexible1npm i lib-flexible --save 2、引入lib-flexible在main.js中引入lib-flexible1import 'lib-flexible/flexible' 3、设置meta标签通过meta标签，设置设备宽度以及缩放比例1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 4、安装px2rem-loader1npm install px2rem-loader 5、配置px2rem-loader在build文件中找到util.js，将px2rem-loader添加到cssLoaders中1234567891011121314const cssLoader = &#123; loader: 'css-loader', options: &#123; minimize: process.env.NODE_ENV === 'production', sourceMap: options.sourceMap &#125; &#125; const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75 &#125; &#125;&#125; 同时，在generateLoaders方法中添加px2remLoader1234567891011function generateLoaders (loader, loaderOptions) &#123; const loaders = [cssLoader,px2remLoader] if (loader) &#123; loaders.push(&#123; loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125;&#125; 6、重启，一切ok~1npm run dev","tags":[{"name":"Vue px rem","slug":"Vue-px-rem","permalink":"http://yoursite.com/tags/Vue-px-rem/"}]},{"title":"'用户注册登录（二）'","date":"2018-08-11T06:23:39.000Z","path":"2018/08/11/用户注册登录（二）/","text":"后台的搭建前面介绍了用户登录注册的前台页面，现在我们开始来介绍一下后台接口的实现。 后台的一些依赖包项目文件组成我们新建一个app.js用来引入Koa12345678910111213141516171819202122232425262728293031323334353637383940const Koa = require(&apos;koa&apos;)const app = new Koa()const json = require(&apos;koa-json&apos;)const onerror = require(&apos;koa-onerror&apos;)const bodyparser = require(&apos;koa-bodyparser&apos;)const logger = require(&apos;koa-logger&apos;)const &#123;check_token&#125; = require(&apos;./utils/token&apos;)// error handleronerror(app)// middlewaresapp.use(bodyparser(&#123; enableTypes:[&apos;json&apos;, &apos;form&apos;, &apos;text&apos;]&#125;))app.use(json())app.use(logger())app.use(require(&apos;koa-static&apos;)(__dirname + &apos;/public&apos;))// 添加token 验证中间件app.use(check_token);// loggerapp.use(async (ctx, next) =&gt; &#123; const start = new Date() await next() const ms = new Date() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`)&#125;)// routesconst index = require(&apos;./routes/index&apos;)app.use(index.routes(), index.allowedMethods())// error-handlingapp.on(&apos;error&apos;, (err, ctx) =&gt; &#123; console.error(&apos;server error&apos;, err, ctx)&#125;);module.exports = app 这里是用户登录注册的接口实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162const User = require(&apos;../db&apos;).User;// const Comment = require(&apos;../db&apos;).Commentconst sha1 = require(&apos;sha1&apos;);const &#123; PWD_ENCODE_STR&#125; = require(&apos;../utils/config&apos;);const &#123;create_token, check_token_code&#125; = require(&apos;../utils/token&apos;);const xss = require(&apos;xss&apos;)module.exports = &#123; // 用户注册 async register(ctx, next)&#123; let &#123;user_name = &apos;&apos;, user_id = &apos;&apos;, user_pwd = &apos;&apos;, re_user_pwd = &apos;&apos;, avatar = &quot;&quot;, code = &apos;&apos;, code_token = &apos;&apos;&#125; = ctx.request.body; try &#123; if(user_name == &apos;&apos; || user_id == &quot;&quot; || user_pwd == &quot;&quot;)&#123; ctx.body = &#123; code: 401, msg: &quot;注册失败，请填写完整表单!&quot; &#125; return; &#125; if(avatar == &apos;&apos;)&#123; ctx.body = &#123; code: 401, msg: &quot;注册失败，请上传头像!&quot; &#125; return; &#125; if(user_pwd.length &lt; 5)&#123; ctx.body = &#123; code: 401, msg: &apos;注册失败，密码最少为5位！&apos; &#125; return; &#125; if(user_pwd != re_user_pwd)&#123; ctx.body = &#123; code: 401, msg: &quot;注册失败，2次密码输入不一致!&quot; &#125; return; &#125; // 验证码判断 let mark = await check_token_code(&#123;token:code_token,code&#125;); if(!mark)&#123; ctx.body = &#123; code: 401, msg: &apos;登录失败，验证码错误!&apos; &#125; return; &#125; // 判断 user_id 是否重复 let res = await User.find(&#123;user_id&#125;); if(res.length != 0)&#123; ctx.body = &#123; code: 409, msg: &apos;注册失败，登录账号重复了，换一个吧！&apos; &#125; return; &#125; user_pwd = sha1(sha1(user_pwd + PWD_ENCODE_STR)); // 防止xss攻击， 转义 user_name = xss(user_name); let token = create_token(user_id); let user = new User(&#123;user_id,user_name,user_pwd,avatar,token&#125;); res = await user.save(); if(res.user_id != null)&#123; ctx.body = &#123; code: 200, msg: &quot;注册成功!&quot;, data: &#123; user_id: res.user_id, user_name, avatar, token, &#125; &#125; &#125;else&#123; ctx.body = &#123; code: 500, msg: &quot;注册失败，服务器异常!&quot; &#125; &#125; &#125;catch (e)&#123; console.log(e); ctx.body = &#123; code: 500, msg: &quot;注册失败，服务器异常！&quot; &#125; &#125; &#125;, // 用户登录 async login(ctx, next)&#123; let &#123;user_id = &apos;&apos;, user_pwd = &apos;&apos; , code = &quot;&quot; , code_token = &apos;&apos;&#125; = ctx.request.body; try &#123; if(user_id == &apos;&apos; || user_pwd == &apos;&apos;)&#123; ctx.body = &#123; code: 401, msg: &quot;登录失败，请输入登录账号或密码!&quot; &#125; return; &#125; // 验证码判断 let mark = await check_token_code(&#123;token:code_token,code&#125;); if(!mark)&#123; ctx.body = &#123; code: 401, msg: &apos;登录失败，验证码错误!&apos; &#125; return; &#125; user_pwd = sha1(sha1(user_pwd + PWD_ENCODE_STR)); let res = await User.find(&#123;user_id,user_pwd&#125;); if(res.length == 0)&#123; ctx.body = &#123; code: 401, msg: &apos;登录失败，用户名或者密码错误!&apos; &#125; return; &#125; let token = create_token(user_id); res[0].token = token; res[0].save(); ctx.body = &#123; code: 200, msg: &quot;登录成功!&quot;, data: &#123; user_id: res[0].user_id, user_name: res[0].user_name, avatar: res[0].avatar, token &#125; &#125; &#125; catch(e)&#123; console.log(e); ctx.body = &#123; code: 500, msg: &apos;登录失败，服务器异常!&apos; &#125; &#125; &#125;, //获取用户头像 async getAvatar(ctx,next)&#123; let user_id = ctx.params.id; try&#123; let res = await User.find(&#123;user_id&#125;); ctx.body = &#123; code: 200, msg: &apos;获取用户头像成功&apos;, data: &#123; userAva: res &#125; &#125; &#125;catch(e) &#123; console.log(e); ctx.body = &#123; code: 500, msg: &quot;获取用户头像失败，服务器异常，请稍后再试！&quot; &#125; &#125; &#125;&#125; 验证码的实现，使用gd-bmp插件来生成验证码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const BMP24 = require(&apos;gd-bmp&apos;).BMP24;const &#123;create_token&#125; = require(&apos;../utils/token&apos;);const Checkcode = require(&apos;../db&apos;).Checkcode;module.exports = &#123; // 验证码获取 async checkcode(ctx, next)&#123; try &#123; let &#123;code,img&#125; = makeCapcha(); let token = create_token(code); await new Checkcode(&#123;token,code&#125;).save(); ctx.body = &#123; code: 200, msg: &apos;获取验证码成功！&apos;, data: &#123; token, img: &quot;data:image/bmp;base64,&quot; + img.getFileData().toString(&apos;base64&apos;) &#125; &#125; &#125; catch(e)&#123; console.log(e); ctx.body = &#123; code: 500, msg: &apos;获取验证码失败！&apos; &#125; &#125; &#125;&#125;function rand(min, max) &#123; return Math.random()*(max-min+1) + min | 0; //特殊的技巧，|0可以强制转换为整数&#125;function makeCapcha() &#123; var img = new BMP24(100, 40); img.drawCircle(rand(0, 100), rand(0, 40), rand(10 , 40), rand(0, 0xffffff)); //边框 img.drawRect(0, 0, img.w-1, img.h-1, rand(0, 0xffffff)); img.fillRect(0, 0, 100, 40, 0x252632); // img.fillRect(rand(0, 100), rand(0, 40), rand(10, 35), rand(10, 35), rand(0, 0xffffff)); img.drawLine(rand(0, 100), rand(0, 40), rand(0, 100), rand(0, 40), rand(0, 0xffffff)); //return img; //画曲线 var w=img.w/2; var h=img.h; var color = rand(0, 0xffffff); var y1=rand(-5,5); //Y轴位置调整 var w2=rand(10,15); //数值越小频率越高 var h3=rand(4,6); //数值越小幅度越大 var bl = rand(1,5); for(var i=-w; i&lt;w; i+=0.1) &#123; var y = Math.floor(h/h3*Math.sin(i/w2)+h/2+y1); var x = Math.floor(i+w); for(var j=0; j&lt;bl; j++)&#123; img.drawPoint(x, y+j, color); &#125; &#125; var p = &quot;ABCDEFGHKMNPQRSTUVWXYZ3456789&quot;; var str = &apos;&apos;; for(var i=0; i&lt;4; i++)&#123; str += p.charAt(Math.random() * p.length |0); &#125; var fonts = [BMP24.font12x24, BMP24.font16x32]; // var fonts = [BMP24.font8x16, BMP24.font12x24, BMP24.font16x32]; var x = 15, y=8; for(var i=0; i&lt;str.length; i++)&#123; var f = fonts[Math.random() * fonts.length |0]; y = 8 + rand(-5, 5); img.drawChar(str[i], x, y, f, rand(0xaaaaaa, 0xffffff)); x += f.w + rand(2, 8); &#125; return &#123;code:str,img&#125;&#125; 后台只是实现了一些简单的交互接口，希望后期对后台的使用能够丰富起来","tags":[{"name":"Vue Mongdb Koa","slug":"Vue-Mongdb-Koa","permalink":"http://yoursite.com/tags/Vue-Mongdb-Koa/"}]},{"title":"用户登录注册（一）","date":"2018-08-10T01:59:29.000Z","path":"2018/08/10/用户登录注册（一）/","text":"最近一直想尝试一下前后台都由自己来写的项目，但是由于刚接触到Mongdb，所以先尝试做一个小项目，思来想去，就拿前端最基本的注册登录来试一下手吧。环境的搭建和Mongdb数据库的可视化软件配置，我这里就不做多的描述了。 服务端语言的选择因为前期对node.js学习了一段时间，在选择后台框架时，就选择了Koa，因为使用起来比较方便，文档很全面。 首先来介绍一下Koa,Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 话不多说，先看前台页面的搭建 前台页面的搭建采用基本的Vue-cli进行基本结构的搭建，因为只是一个登陆注册的页面，所以页面结构很简单，一个首页，注册页、登陆页，以及一个下单页面。先来看一下首页的效果图首页这里点击立即下单，判断用户如果有没有登陆，如果vuex中存在用户的token,那么页面直接跳转到下单页面，如果vuex中没有存在用户的token，或者存储用户的token已经过期，那么提示用户你还没有登陆，请先登录再进行下单。 1234567891011order()&#123; //获取store里面的token let token = store.state.user.token; if(token)&#123; //如果存在token，说明已经登录，跳往下单页面 this.$router.push(&apos;/Order&apos;); &#125;else&#123; this.modalShowOneBtn=true; this.modalOneBody=&apos;您还没有登录，请先登录，再进行下单操作！&apos; &#125; &#125; 验证码由后台直接生成base64的地址，然后前台进行获取，点击图片进行验证码的切换123456789101112async get_check_code() &#123; let res = await this.$http.api_get_checkcode(); let &#123; code, msg, data = &#123;&#125; &#125; = res.data; if (code == 200) &#123; this.img_base64 = data.img; this.user.code_token = data.token; &#125; &#125; 用户如果已经有账号，那么在输入账号的时候，可以异步获取用户的头像，提升用户的使用体验。12345678910111213141516async get_user_avatar(id) &#123; let res = await this.$http.api_getAvatar(id); // console.log(res.data); let &#123; code, msg, data &#125; = res.data; if (code == 200) &#123; if(data.userAva.length!==0)&#123; this.userAvatar = data.userAva[0].avatar; &#125;else&#123; this.userAvatar = require(&apos;../assets/logo.png&apos;); &#125; &#125; &#125;, 如果没有账号可以随时进行注册，这里用户可以上传头像，我采用了vue-cropper插件进行用户头像的裁剪。 1234567891011121314151617upload_img(e) &#123; let obj = e.target; let file = obj.files[0]; let temArr = file.name.split(&quot;.&quot;); let file_suffix = temArr[temArr.length - 1]; if (file_suffix != &apos;jpg&apos; &amp;&amp; file_suffix != &apos;png&apos; &amp;&amp; file_suffix != &apos;jpeg&apos;) &#123; this.$toast.center(&apos;上传图片失败，目前只支持jpg,png,jpeg的图片!&apos;); return; &#125; let reader = new FileReader(); let _self = this; reader.onload = function(ev) &#123; _self.cropperData.img = ev.target.result; _self.cropper_box_mark = true; &#125; reader.readAsDataURL(file); &#125;","tags":[{"name":"Vue Mongdb Koa","slug":"Vue-Mongdb-Koa","permalink":"http://yoursite.com/tags/Vue-Mongdb-Koa/"}]},{"title":"Vue的世界","date":"2018-03-18T08:12:44.000Z","path":"2018/03/18/Vue的世界/","text":"Vue实例上的属性 组件树 $parent：用来访问组件实例的父实例 $root: 用来访问当前组件树的根实例 $children:用来访问当前组件实例的直接子组件实例 $refs:用来访问ref指令的子组件 Dom访问 $el：用来挂载当前组件实例的dom元素 $els：用来访问$el元素中使用了v-el指令的DOM元素 数据访问 $data：用来访问组件实例观察的数据对象 $options：用来访问组件实例化时的初始化选项对象 DOM方法的使用 $appendTo(elementOrSelector, callback)：将el所指的DOM元素插入目标元素 $before(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之前 $after(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之后 $remove(callback)：将el所指的DOM元素或片段从DOM中删除 $nextTick(callback)：用来在下一次DOM更新循环后执行指定的回调函数 event方法的使用1.监听$on(event, callback)：监听实例的自定义事件$once(event, callback)：同上，但只能触发一次$watch(property,callback(new, old)): 监听属性的变化，拿到变化前后的值 12345678910111213141516 // 第一种写法watch: &#123; text(new, old) &#123; console.log(`$&#123;new&#125;：$&#123;old&#125;`); &#125;&#125;// 第二种写法const unWatch = this.$watch('text',(new,old)=&gt; console.log(`$&#123;new&#125;：$&#123;old&#125;`);&#125;)// 2秒后销毁 unWatchsetTimeout(()=&gt; &#123; unWatch();&#125;,2000)// 两种写法的结果一样，只是第二种需要在组件销毁手动销毁$watch 2.触发$dispatch(event,args)：派发事件，先在当前实例触发，再沿父链一层层向上，对应的监听函数返回false停止$broadcast(event,args)：广播事件，遍历当前实例的$children，如果对应的监听函数返回false，就停止$emit(event, args)：触发事件3.删除$off(event, callback)：删除时间监听4.其他$forceUpdate()：强制组件刷新$set(ele,attr,value)：给对象设置属性$delete(ele,attr,value)：删除对象属性123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;obj.a&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; obj:&#123;&#125; &#125;; &#125; mounted()&#123; let i = 0; setInterval(()=&gt; &#123; i++; // 第一种 this.obj.a = i ; // obj.a没有定义，vue是无法监听到这个属性的变化，所以页面的值也不会变化，这时可以用$forceUpdate进行强制渲染，当然不推荐这种用法 this.$forceUpdate(); // 第二种 this.$set(this.obj,'a',i); &#125;,1000) &#125;&#125;&lt;/script&gt; v-model 的修饰符 来自官网的例子： 1..number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：1&lt;input v-model.number=\"age\" type=\"number\"&gt; 这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。 2..trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：1&lt;input v-model.trim=\"msg\"&gt; 3..lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步(当输入框失去焦点)： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; 数组和对象要特别注意的1. 数组由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength 1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： 12// Vue.setVue.set(vm.items, indexOfItem, newValue) 12// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名： 1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice： 1vm.items.splice(newLength) 2. 对象Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于：1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名： 1vm.$set(vm.userProfile, 'age', 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做：1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) computed 计算属性计算属性的使用1234567891011121314151617181920&lt;template&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; firstName: 'Fin', lastName: 'Get', &#125;; &#125;, computed: &#123; name() &#123; return `$&#123;this.firstName&#125;$&#123;this.lastName&#125;` &#125; &#125;&#125;&lt;/script&gt; 双向绑定的计算属性与Vuex12345678910111213// vuex state是无法直接修改的，官方给出了 v-model 的解决方案&lt;input v-model=\"message\"&gt;computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125; 如果在方法或者生命周期中使用了计算属性，则必须设置一个set watch 监听器watch 简单使用123456789101112131415161718192021222324252627&lt;div id=\"demo\"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; // watch 方法最初绑定的时候，它是不会执行的，只有变化了才会执行 firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;)watch: &#123; // 声明一个handler，这样在初始化时就会执行一次 handler firstName: &#123; handler(val) &#123; this.fullName = val + ' ' + this.lastName &#125;, immediate: true &#125;&#125; 监听对象属性的变化12345678910111213141516171819202122232425262728&lt;div id=\"demo\"&gt;&#123;&#123; obj.a &#125;&#125;&lt;/div&gt;&lt;input v-model=\"obj.a\" /&gt;var vm = new Vue(&#123; el: '#demo', data: &#123; obj: &#123; a: '123' &#125; &#125;, watch: &#123; obj: &#123; handler() &#123; console.log('obj.a changed'); &#125;, immediate: true, deep: true // 如果不加这一句，在输入框中输入值，并不会打印 obj.a changed &#125; &#125;&#125;)// 这样写就能监听到属性值的变化watch: &#123; 'obj.a': &#123; handler() &#123; console.log('obj.a changed'); &#125; &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"React井字小游戏","date":"2017-07-05T07:24:25.000Z","path":"2017/07/05/React井字小游戏/","text":"React井字小游戏在React官方文档中，有一个很适合菜鸟练手的React项目，React井字小游戏。在这篇教程里，主要涉及到了es6的一些语法。 现在我们这里已经搭建好一个基本的游戏模板，你可以点击这里进行下载 首先来搭建React的基本运行环境1、首先需要你安装最新版的node2、点击创建新的React项目3、删除掉src文件夹下的所有文件4、在 src/ 文件夹下新建一个名为 index.css 的文件并拷贝 这里的 CSS 代码 到文件中。5、在 src/ 文件夹下新建一个名为 index.js 的文件并拷贝 这里的 JS 代码 到文件中, 并在此文件的最开头加上下面几行代码： 1234import React from 'react';import ReactDOM from 'react-dom';import './index.css'; 在完成上述操作以后，可以运行cmd进行依赖的安装，运行项目以后，点击http://localhost:3000/就可以看到这样的呈现效果 不过现在还没有添加功能，接下来给模板添加一些功能 12345678//棋盘上单独的一个格子function Square(props)&#123; return( &lt;button className=\"square\" onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125; props &amp;&amp; state props用于各个组件之间传递数据,state用于组件内部更新状态react推荐凡是组件通信数据都是通过props。他与state的区别在于，state是通过setState来更新的，props是通过组件的生命周期来更新的，这意味着，组件生命周期不发生变化，props是不会变的. 子组件Square上绑定的onClick事件是从父组件Board由props.onClick属性传递过来的 12345678910111213141516171819202122232425262728293031//棋盘主体class Board extends React.Component &#123;//这里渲染出每一个棋格 renderSquare(i) &#123; return &lt;Square value=&#123;this.props.squares[i]&#125; onClick=&#123;()=&gt;this.props.onClick(i)&#125; /&gt;; &#125; render() &#123; return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; Game组件里编写了我们小游戏的基本逻辑，在这里要阐述一下React的状态提升，以及它的必要性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Game 组件则为我们即将要编写的代码预留了一些位置class Game extends React.Component &#123;//保存初始化状态 constructor()&#123; super(); this.state=&#123; history:[&#123; squares:Array(9).fill(null), &#125;], stepNumber:0, xIsNext:true, &#125; &#125; handleClick(i)&#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current=history[history.length-1]; const squares=current.squares.slice(); //const squares=this.state.squares.slice();//.slice()方法将之前的数组数据深拷贝到一个新的数组中 if(calculateWinner(squares)||squares[i])&#123; return; &#125; squares[i]=this.state.xIsNext?'X':'O'; this.setState(&#123; history:history.concat([&#123; squares:squares &#125;]), stepNumber: history.length, xIsNext:!this.state.xIsNext, &#125;); &#125; jumpTo(step) &#123; this.setState(&#123; stepNumber: step, xIsNext: (step % 2) ? false : true, &#125;); &#125; render() &#123; const history =this.state.history.slice(0,this.state.stepNumber+1); const current =history[this.state.stepNumber]; const winner =calculateWinner(current.squares); const moves=history.map((step,move)=&gt;&#123; const desc=move? 'Move #'+move: 'Game start'; return( &lt;li key=&#123;move&#125;&gt; &lt;a href=\"#\" onClick=&#123;()=&gt;this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; ) &#125;); let status; if(winner)&#123; status=\"Winner:\"+winner; &#125;else&#123; status=\"Next player:\"+(this.state.xIsNext?'X':'O') &#125; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares=&#123;current.squares&#125; onClick=&#123;(i)=&gt;this.handleClick(i)&#125;/&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过props 将状态数据传递到子组件当中。这样应用当中的状态数据就能够更方便地交流共享了。在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。 在 React 组件的构造方法 constructor 当中，你可以通过 this.state 为该组件设置自身的状态数据。试着把棋盘格子变化的数据储存在组件的state 当中： 1234567891011//es6中的语法，把组件中的初始化状态，保存在constructor中constructor()&#123; super(); this.state=&#123; history:[&#123; squares:Array(9).fill(null), &#125;], stepNumber:0, xIsNext:true, &#125; &#125; 在constructor中存储了状态数据 handleClick用户操作的基本方法都由这里进行挂载派发，传递，然后子组件由props进行接收 123456789101112131415161718192021handleClick(i)&#123; //这里保存着棋盘的状态历史 const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length-1]; const squares = current.squares.slice(); //const squares=this.state.squares.slice();//.slice()方法将之前的数组数据深拷贝到一个新的数组中 if(calculateWinner(squares)||squares[i])&#123; return; &#125; squares[i]=this.state.xIsNext?'X':'O'; this.setState(&#123; history:history.concat([&#123; squares:squares &#125;]), stepNumber: history.length, xIsNext:!this.state.xIsNext, &#125;); &#125;","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"node第二天","date":"2017-07-04T08:12:32.000Z","path":"2017/07/04/node第二天/","text":"package.json的作用在这里我们要引入utility，需要在package.json中进行配置 app.js中代码如下1234567891011121314151617//引入依赖var express = require('express');var utility = require('utility');var app = express();app.get('/', function (req, res) &#123;//获得请求头部 var q = req.query.q; //使用md5进行加密 var md5Value = utility.md5(q); res.send(md5Value);&#125;);app.listen(3000, function (req, res) &#123; console.log('app is running at port 3000');&#125;); 这里我们在cmd中运行app.js，但是这次不同的地方在于，我们访问的网页地址需要作出一些变化访问 http://localhost:3000/?q=alsotang 完成结果如下 题外话如果直接访问 http://localhost:3000/ 会抛错 可以看到，这个错误是从 crypto.js 中抛出的。 这是因为，当我们不传入 q 参数时，req.query.q 取到的值是 undefined，utility.md5 直接使用了这个空值，导致下层的 crypto 抛错。","tags":[{"name":"node utility","slug":"node-utility","permalink":"http://yoursite.com/tags/node-utility/"}]},{"title":"node第一天","date":"2017-07-04T07:51:19.000Z","path":"2017/07/04/node第一天/","text":"《搭建 Node.js 开发环境》其实这过程特别简单: node的版本管理工具，可以用来安装、切换node的版本， 先安装一个 nvm（ https://github.com/creationix/nvm ）1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。 安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试 1$ nvm 当看到有输出时，则 nvm 安装成功。 安装 Node.js使用 nvm 的命令安装 Node.js 最新稳定版，现在是 v0.12.3。 1$ nvm install 0.12 安装完成后，查看一下 1$ nvm ls 这时候可以看到自己安装的所有 Node.js 版本，输出应如下： （图1） 那个绿色小箭头的意思就是现在正在使用的版本，我这里是 v0.10.29。我还安装了 v0.11.14，但它并非我当前使用的版本。 如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 0.12.x 版本 1$ nvm use 0.12 然后再次查看，这时候小箭头应该出现了。 OK，我们在终端中输入 1$ node REPL(read–eval–print loop) 应该就出来了，那我们就成功了。 随便敲两行命令玩玩吧。 比如 &gt; while (true) {}，这时你的 CPU 应该会飚高。 完善安装上述过程完成后，有时会出现，当开启一个新的 shell 窗口时，找不到 node 命令的情况。 这种情况一般来自两个原因 一、shell 不知道 nvm 的存在 二、nvm 已经存在，但是没有 default 的 Node.js 版本可用。 解决方式： 一、检查 ~/.profile 或者 ~/.bash_profile 中有没有这样两句 12export NVM_DIR=&quot;/Users/YOURUSERNAME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 没有的话，加进去。 这两句会在 bash 启动的时候被调用，然后注册 nvm 命令。 二、 调用 $ nvm ls 看看像不像上述图1中一样，有 default 的指向。 如果没有的话，执行 $ nvm alias default 0.12 再 $ nvm ls 看一下 Hello World首先创建一个js文件，这里我命名为app.js 1234567891011var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 1234567891011121314151617// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。var express = require('express');// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。var app = express();// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 然后打开cmd 运行app.js文件我们可以看到 在浏览器中显示的内容","tags":[{"name":"node nvm","slug":"node-nvm","permalink":"http://yoursite.com/tags/node-nvm/"}]},{"title":"http知识点","date":"2017-05-20T09:02:33.000Z","path":"2017/05/20/http知识点/","text":"http知识点对于http的报文格式就不多细说了，因为做为前端开发，我们需要知道前后端联调时的请求和响应之间请求头和返回头之间的关系和每个字段中的涵意，静态文件资源在加载时我们所观察到能够性能优化的点，和一些日常请求报错如何去解决的坑，更重要的是面试的时候如何去从容的应对面试官。 谈到http，就少不了最常见的一个问题，跨域，当我们使用api接口进行数据请求时，浏览器的控制台控制台中，报出了这样的错误，恭喜你，你跨域了。1Failed to load http://http:www.pilishou.com: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled. 在本地向不同域请求的时候，浏览器会做一个Origin请求头的验证，如果没有设置，在不同域名下或者本地请求时浏览器会向服务端发送请求，服务端也会客户端发送对应的值，但是浏览器考虑到安全策略，会进行一个关于头信息的报错，此时对于后端来说，需要在response的返回头中加入1&apos;Access-Control-Allow-Origin&apos;: &apos;*&apos; 来告诉浏览器我允许你进行一个跨域请求，不用报错，把值返回给请求者，这样你就可以安然的拿到数据。同时这样也会导致任何一个域名发送过来的请求，都允许跨域的情况下，可以针对’Access-Control-Allow-Origin’: ‘此处设置指定的域名’ 12345678910111213在简单的跨域请求中1.请求方法是以下三种方法之一：HEADGETPOST2.HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 如果不超过以上的限制,后端则只需要提供一个允许跨域的Origin就可以了，如果在请求方法超过了以上三种，需要添加’Access-Control-Allow-Methods’: ‘PUT’,同样浏览器为了安全，不允其它请求方法在台端没有设置允许的方法中进行一个跨域请求 在非同源的请求情况下，浏览器会首先进行Option请求，所谓的预请求，就是试探性请求，向服务端请求的时候，发现此接口设置了允许对应的请求方法或者请求头，会再次发送真正的请求，分别一共会向后台发送两次请求，拿自己想要的数据，在OPTION请求时，服务端也会返回数据，但是在浏览器层被做了屏闭，如果没有检测出对应的跨域设置则会报出对应的错误。 ###可以减少预请求次数 在本地联调时，每次发送一个非简单请求时都会发送一个预请求，预请求也是一个花费时间和资源的操作，就像一次实名质认证过了，在一定时间内就不用实名质认正了，原理一样，如果当前请求的域名第一次认证通过，则在一定的时间内不需要进行一个二次认证，但是需要进行一次认证的时间控制，通过’Access-Control-Max-Age’: ‘860000’，返回，一旦在这个时间之内再次发送时，直接发送真正的请求，不通要再通过预请求Option方法进行一个探测认证。 cache-control 的使用场景和性能优化 cache-control这个东西就是对服务端拉取的静态资源打上一个缓存标志对于cache-control可以设置几种模式，通常前端工程师又需要知道那几种模式 max-age = 10000 (以秒为音位，根据需求设定)no-cache (每次进行请求时都要向服务端进行验证，需要配合etag,Last-Modified)使用no-store (每次请求都需要向服务端拉取新的资源)privite (私有的，不经过代理缓存)public (公有的，如果本地失效，代理缓存存在的话可以从代理缓存进行通知用过期的资源) max-age当加载完资源时，浏览器会自动给我们存储到内存当中，但是浏览内部的失效时间是由内部机制控制的，在用nginx做静态资源的时候，在刷新的时候，浏览会向服务端再次发送是否过期的认证，在资源缓存时间的确定情况下，通过max-age指定强缓存后,浏览器再次加载同样的资源文件时，只需要从memory或者disk上面进行拉取复用达到以上的功能需要在返回资源的服务端的对返回的资源设置’cache-control’: ‘max-age=时间（以秒为单位）’,当再次刷新页面的时候，在设置的时间之内，刷新页面，不清除缓存的情况下都会重新拉取内存了中的缓存资源。no-cacheno-cache 字面的字意是不缓存的意思，但是很容易迷惑人，但是本质的函意，意味着每次发送请求静态资源时都需要向服务端进行一次过期认证，通常情况下，过期认真证需要配合（etag和Last-Modified）进行一个比较，这个话题后继再展开讨论，如果验证并没有过期，则会发送304的状态码，通知浏览进复用浏览器的缓存no-storeno-store 代表每次资源请求都拉取资源服务器的最新资源，就算同时设置max-age , no-store, no-store的优先级则最高，此时max-age则不生效，同样的会从服务端拉取最新的资源private vs public在资源请求时，有些情况不会直接到原资源服务器发送请求，中间会经过一些代理服务器，比如说cdn,nginx等一些代理服务器，如果写入public的情况下，所有的代理服务器同样也会进行缓存，比如说s-maxage就是在代理缓存中生效的，如果本地max-age过期了，则会通过代理缓存，代理缓存并没有过期，会告诉浏览器还是可以用本地过期的缓存，但对于private中间代理服务器则不会生效，直接从浏览器端向原服务器进行一个验证。 ###缓存验证 Last-Modified 和 Etag Last-Modified最后修改时间，一般在服务端，对文件的修改都会有一个修改时间的记录，在nginx做静态资源时，nginx会返回一个Last-Modified最后修改的时间，在浏览器再次请求的时候，会把对应的If-Modified-Since和 If-UnModified-Since在请求头中再次发送给服务端，告诉服务端上次你给我文件改动的时间，但是Last-Modified只能以秒为单位，在有些情况下，是不够精确的Etag是一个更加比较严格的验证，主要通过一些数据签名，每个数据都有自己的唯一签名，一旦数据修改，则会生成另一个唯一的签名，最典型的做法就是对内容做一个hash计算，当浏览器端向服务端再请求的时会带上 IF-Match 或者 If-Non-Match,当服务端接收到后之后会对比服务端的签名和浏览器传过来的签名，这也是弥补了Last-Modified只能以秒为单位，在有些情况下，是不够精确的情况Last-Modified和Etag 配合 no-cache 使用通常只会在 cache-control 在 no-cache的情况下，浏览器也会对资源进行一个缓存， 同时会对服务端进行一个认证过期，一旦服务端返回304状态码，则说明可以复用浏览器的缓存，则会向服务端重新请求数据。cookie的策略机制cookie则是一个服务端和用端之间一个像身份证认证一样的东西，一旦后端在返回头中设置了cookie,则在response中会出现设置的cookie数据，同时也会存在浏览器的application/cookie中，当每次发送请求的时候都会在request的头中带上当前域名下的cookie信息","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"sass语法","date":"2017-05-19T02:53:44.000Z","path":"2017/05/19/sass语法/","text":"SASS语法（上） 学过CSS的人都知道，它不是一种编程语言。 你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。 很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。 下面是我整理的sass用法总结。 文件后缀名sass有两种后缀名文件：一种后缀名为sass，不使用大括号和分号；另一种就是我们这里使用的scss文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。而本教程中所说的所有sass文件都指后缀名为scss的文件。在此也建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。 123456789101112131415//文件后缀名为sass的语法body background: #eee font-size:12pxp background: #0982c1//文件后缀名为scss的语法body &#123; background: #eee; font-size:12px;&#125;p&#123; background: #0982c1;&#125; 导入sass的导入(@import)规则和CSS的有所不同，编译时会将@import的scss文件合并进来只生成一个CSS文件。但是如果你在sass文件中导入css文件如@import ‘reset.css’，那效果跟普通CSS导入样式文件一样，导入的css文件不会合并到编译后的文件中，而是以@import方式存在。所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import “mixin”。被导入sass文件a.scss：12345//a.scss//-------------------------------body &#123; background: #eee;&#125; 需要导入样式的sass文件b.scss：12345@import \"reset.css\";@import \"a\";p&#123; background: #0982c1;&#125; 转译出来的b.css样式：1234567@import \"reset.css\";body &#123; background: #eee;&#125;p&#123; background: #0982c1;&#125; 根据上面的代码可以看出，b.scss编译后，reset.css继续保持import的方式，而a.scss则被整合进来了。 变量sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样），如果值后面加上!default则表示默认值。普通变量定义之后可以在全局范围内使用。123456789101112//sass style//-------------------------------$fontSize: 12px;body&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:12px;&#125; 默认变量sass的默认变量仅需要在值后面加上!default即可。123456789101112//sass style//-------------------------------$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight;&#125;//css style//-------------------------------body&#123; line-height:1.5;&#125; sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可12345678910111213//sass style//-------------------------------$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight;&#125;//css style//-------------------------------body&#123; line-height:2;&#125; 可以看出现在编译后的line-height为2，而不是我们默认的1.5。默认变量的价值在进行组件化开发的时候会非常有用。特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用。1234567891011121314151617181920212223//sass style//-------------------------------$borderDirection: top !default;$baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;//应用于复杂的属性值body&#123; font:#&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style//-------------------------------.border-top&#123; border-top:1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 多值变量多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。listlist数据可通过空格，逗号或小括号分隔多个值，可用nth($var,$index)取值。关于list数据操作还有很多其他函数如length($list)，join($list1,$list2,[$separator])，append($list,$value,[$separator])等定义123456//一维数据$px: 5px 10px 20px 30px;//二维数据，相当于js中的二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px); 使用12345678910111213141516171819//sass style//-------------------------------$linkColor: #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;//css style//-------------------------------a&#123; color:#08c;&#125;a:hover&#123; color:#333;&#125; mapmap数据以key和value成对出现，其中value又可以是list。格式为：$map: (key1: value1, key2: value2, key3: value3);。可通过map-get($map,$key)取值。关于map数据还有很多其他函数如map-merge($map1,$map2)，map-keys($map)，map-values($map)等，具体可参考sass Functions（搜索Map Functions即可）定义1$heading: (h1: 2em, h2: 1.5em, h3: 1.2em); 使用1234567891011121314151617181920//sass style//-------------------------------$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css style//-------------------------------h1 &#123; font-size: 2em;&#125;h2 &#123; font-size: 1.5em;&#125;h3 &#123; font-size: 1.2em;&#125; 全局变量在变量值后面加上!global即为全局变量。这个目前还用不上，不过将会在sass 3.4后的版本中正式应用。目前的sass变量范围饱受诟病，所以才有了这个全局变量。目前变量机制在选择器中声明的变量会覆盖外面全局声明的变量。(这也就人们常说的sass没有局部变量)12345678910111213141516171819//sass style//-------------------------------$fontSize: 12px;body&#123; $fontSize: 14px; font-size:$fontSize;&#125;p&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:14px;&#125;p&#123; font-size:14px;&#125; 启用global之后的机制请注意，这个目前还无法使用，所以样式不是真实解析出来的。12345678910111213141516171819202122232425//sass style//-------------------------------$fontSize: 12px;$color: #333;body&#123; $fontSize: 14px; $color： #fff !global; font-size:$fontSize; color:$color;&#125;p&#123; font-size:$fontSize; color:$color;&#125;//css style//-------------------------------body&#123; font-size:14px; color:#fff;&#125;p&#123; font-size:12px; color:#fff;&#125; 这里设置了两个变量，然后在body里面重新设置了下，有点不同的是对于$color变量，我们设置了!global。通过编译后的css可以看到font-size取值不同，而color取值相同。与上面的机制对比就会发现默认在选择器里面的变量为局部变量，而只有设置了!global之后才会成为全局变量。","tags":[]},{"title":"React Router","date":"2017-05-12T05:46:33.000Z","path":"2017/05/12/React Router/","text":"1、React Router的作用 一、React Router解决了React components 到URl之间的同步映射关系 二、Route组件定义了URL路径与组件的对应关系 三、路由器Router其实就是React的一个组件，在使用的时候，直接引用。 下面举一个例子，在没有使用React Router时，我们的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243var About = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;About&lt;/h2&gt;; &#125;&#125;);var Inbox = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;Inbox&lt;/h2&gt;; &#125;&#125;);var Home = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;Home&lt;/h2&gt;; &#125;&#125;);var App = React.createClass(&#123; render () &#123; var Child; switch (this.props.route) &#123; case 'about': Child = About; break; case 'inbox': Child = Inbox; break; default: Child = Home; &#125; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;Child/&gt; &lt;/div&gt; ) &#125;&#125;);function render () &#123; var route = window.location.hash.substr(1); React.render(&lt;App route=&#123;route&#125; /&gt;, document.body);&#125;window.addEventListener('hashchange', render);render(); // render initially 一、在hash值改变的时候，App 将会根据this.props.route值的改变来动态渲染 component。 二、这样的做法虽然看起来很直接，但是会导致整个应用程序变得更加复杂。比如，如果组件 Inbox 有一些内嵌的子组件需要根据 例如 inbox/message/:id 或者 inbox/unread 等这样的路由规则做动态渲染的时候。我们需要一些更加智能的手段来把路由信息传递给我们的App，这样Inbox 组件可以根据URL的映射关系来控制哪些子组件应该需要被渲染。 三、很多组件应该根据URL的规则来做动态渲染。在不使用路由规则的前提下，复杂一点的路由需求就需要我们写很多条件判断的代码去去解决实RL和层级组件的同步问题。 引入React Router 123456789101112131415161718192021222324252627282930313233343536373839404142var Router = require('react-router'); var Route = Router.Route; // declare our routes and their hierarchy var routes = ( &lt;Route handler=&#123;App&#125;&gt; &lt;Route path=\"about\" handler=&#123;About&#125;/&gt; &lt;Route path=\"inbox\" handler=&#123;Inbox&#125;/&gt; &lt;/Route&gt; ); var RouteHandler = Router.RouteHandler; var App = React.createClass(&#123; render () &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RouteHandler/&gt; &lt;/div&gt; ) &#125; &#125;); Router.run(routes, Router.HashLocation, (Root) =&gt; &#123; React.render(&lt;Root/&gt;, document.body); &#125;); var Message = React.createClass(&#123; render () &#123; return &lt;h3&gt;Message&lt;/h3&gt;; &#125; &#125;); var routes = ( &lt;Route handler=&#123;App&#125;&gt; &lt;Route path=\"about\" handler=&#123;About&#125;/&gt; &lt;Route path=\"inbox\" handler=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" handler=&#123;Message&#125;/&gt; &lt;/Route&gt; &lt;/Route&gt; ); 一、Root 是 React Router 路由匹配后决定渲染的最高层级的组件，告诉 RouterHandle 应该渲染的内容是什么。 组件是不会被渲染的。只是一个创建内部路由规则的配置对象。 二、解决复杂的URL和层级组件之间的映射关系式React Router 的核心。 三、使用声明式的方式为举的例子引入路由。使用JSX的方式来进行路由的配置，这样就可以通过属性的方式来配置页面视图的层级关系。 2、Redirect 组件 1234&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125; ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt; &lt;/Route&gt; 一、Redirect组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。 二、{/ 从 /inbox/messages/:id 跳转到 /messages/:id /}","tags":[]},{"title":"React练习Todolist","date":"2017-05-08T05:42:10.000Z","path":"2017/05/08/React练习Todolist/","text":"todolist页面效果 基本功能 1、用户可以添加任务，当用户输入的内容为空时，不添加。 2、用户可以随时切换任务的完成状态，并进行显示提示已完成数量与总任务数量 3、用户可以删除列表中的任一任务。Demo地址：查看Demo地址 创建React组件 创建TodoBox组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var TodoBox = React.createClass(&#123; getInitialState: function() &#123; return &#123; data: [ &#123;\"id\": \"0001\", \"task\":\"吃饭\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0002\", \"task\":\"睡觉\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0003\", \"task\":\"打豆豆\", \"complete\": \"true\"&#125; ] &#125;; &#125;, // 根据id删除一项任务 handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;); &#125;, // 切换一项任务的完成状态 handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;); &#125;, // 给新增的任务一个随机的id generateId: function() &#123; return Math.floor(Math.random() * 9000) + 1000; &#125;, // 新增一项任务 handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//链接两个对象 this.setState(&#123;data&#125;); &#125;, render: function() &#123; var statistics = &#123; // 统计任务总数及完成的数量 todoCount: this.state.data.length || 0, todoCompleteCount: this.state.data.filter(function(item) &#123; return item.complete === \"true\"; &#125;).length &#125;; return ( &lt;div className=\"well\"&gt; &lt;h1 className=\"text-center\"&gt;React Todo&lt;/h1&gt; &lt;TodoList data=&#123;this.state.data&#125; deleteTask=&#123;this.handleTaskDelete&#125; toggleComplete=&#123;this.handleToggleComplete&#125; todoCount=&#123;statistics.todoCount&#125; todoCompleteCount=&#123;statistics.todoCompleteCount&#125; /&gt; &lt;TodoForm submitTask=&#123;this.handleSubmit&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); 1、获取当前组件的初始化状态，在TodoBox组件中，定义该组件所要使用的方法。 2、删除该项任务的功能：根据Id删除一项任务，首先获取该组件在删除任务之前的所有任务列表，根据传入的id进行过滤判断，返回其他项任务，进行删除传入id的任务项。更新当前状态值。 1234567handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;);&#125;, 3、切换任务的完成状态功能：传入的值仍为任务当前的Id值，先获取初始数据进行遍历，判断当前任务的complete属性值是什么，使用三元表达式进行判断转换，如：初始值为true，就转换成false，反之亦然。更新当前状态值。 12345678910handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;);&#125;, 4、添加任务功能：设定该任务项的基本属性（id，task,complete）,并与之前获得的状态任务列表进行合并并更新当前状态值。 1234567handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//连接两个对象 this.setState(&#123;data&#125;); &#125;, 创建TodoList组件12345678910111213141516171819202122var TodoList = React.createClass(&#123; render: function() &#123; var taskList = this.props.data.map(function(listItem) &#123; return ( &lt;TodoItem taskId=&#123;listItem.id&#125; key=&#123;listItem.id&#125; task=&#123;listItem.task&#125; complete=&#123;listItem.complete&#125; deleteTask=&#123;this.props.deleteTask&#125; toggleComplete=&#123;this.props.toggleComplete&#125; /&gt; ) &#125;, this); return ( &lt;ul className=\"list-group\"&gt; &#123;taskList&#125; &lt;TodoFooter todoCount=&#123;this.props.todoCount&#125; todoCompleteCount=&#123;this.props.todoCompleteCount&#125; /&gt; &lt;/ul&gt; ); &#125;&#125;); 1、这里介绍一下React中的props与state的区别state作用 更新组件的state，会导致用户界面的重新渲染（不用操作DOM）,直白来说就是用户的界面会跟着state的变化而变化。props作用 是一种父级向子级传递数据的方式，也就是说从拥有者流向归属者。这里this.props.data.map()组件从父级获取数据并进行遍历。 创建TodoItem组件12345678910111213141516171819202122232425262728293031323334353637383940414243var TodoItem = React.createClass(&#123; toggleComplete: function() &#123; this.props.toggleComplete(this.props.taskId); &#125;, deleteTask: function() &#123; this.props.deleteTask(this.props.taskId); &#125;, // 鼠标移入显示删除按钮 handleMouseOver: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"inline\"; &#125;, handleMouseOut: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"none\"; &#125;, render: function() &#123; var task = this.props.task; var classes = \"list-group-item\"; var itemChecked; if (this.props.complete === \"true\") &#123; task = &lt;s&gt;&#123;task&#125;&lt;/s&gt;; itemChecked = true; classes += \" list-group-item-success\" &#125; else &#123; itemChecked = false; &#125; return ( &lt;li className=&#123;classes&#125; onMouseOver=&#123;this.handleMouseOver&#125; onMouseOut=&#123;this.handleMouseOut&#125;&gt; &lt;input type=\"checkbox\" checked=&#123;itemChecked&#125; onChange=&#123;this.toggleComplete&#125; className=\"pull-left\" /&gt; &#123;task&#125; &lt;div className=\"pull-right\"&gt; &lt;button type=\"button\" className=\"btn btn-xs close\" onClick=&#123;this.deleteTask&#125; ref=\"deleteBtn\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ); &#125;&#125;); 1、要介绍ref属性，首先得介绍一下render()特别注意的是：从 render() 返回来的不是你实际绘制的子组件的实例。从 render() 返回来的仅仅是一个特定的时刻在你组成部分的 sub-hierarchy 中的子组件实例的描述。所以，要想获得在TodoItem中render()里返回的删除按钮，需要在按钮本身上添加ref属性。 2、这里介绍一下React中的ref属性refs作用 React 支持一个非常特殊的属性，你可以附加到任何从 render() 输出的组件中。这个特殊的属性允许你涉及相应的任何从 render() 返回的支持实例。它总是保证成为适当的实例，在任何时候。 其余组件的创建12345678910111213141516171819202122232425262728293031323334353637383940var TodoFooter = React.createClass(&#123; render: function() &#123; return ( &lt;li className=\"list-group-item\"&gt;&#123;this.props.todoCompleteCount&#125;已完成 / &#123;this.props.todoCount&#125;总数&lt;/li&gt; ) &#125;&#125;);var TodoForm = React.createClass(&#123; submitTask: function(e) &#123; e.preventDefault(); var task = ReactDOM.findDOMNode(this.refs.task).value.trim(); if (!task) &#123; return; &#125; this.props.submitTask(task); ReactDOM.findDOMNode(this.refs.task).value = \"\"; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;hr /&gt; &lt;form className=\"form-horizontal\" onSubmit=&#123;this.submitTask&#125;&gt; &lt;div className=\"form-group\"&gt; &lt;label for=\"task\" className=\"col-md-2 control-label\"&gt;Task&lt;/label&gt; &lt;div className=\"col-md-10\"&gt; &lt;input type=\"text\" id=\"task\" ref=\"task\" className=\"form-control\" placeholder=\"你想做点什么\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"row\"&gt; &lt;div className=\"col-md-12 text-right\"&gt; &lt;input type=\"submit\" value=\"Save Task\" className=\"btn btn-primary\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125;); 心得总结 刚开始使用React做简单的案例，总感觉没有了以前的DOM操作，很不适应，尤其是React中的JSX语法糖中html与js混合编写，真的是感觉很不适应。但是当真正做完一两个项目以后， 才发现React组件化的思想对于后续代码的管理和维护，以及编程前的思维逻辑方便了很多，自己在React的道路上才刚刚开始，希望在探索React的道路上，努力前行！！！","tags":[]},{"title":"Demo练习","date":"2017-04-25T04:46:36.000Z","path":"2017/04/25/Demo练习/","text":"用户评论功能 用户可以发表评论，使用React组件化 在github上还有功能扩展，从后台读取数据，渲染到列表下方 用户输入的实时评论也可以写入后台服务器 Demo地址：查看Demo地址","tags":[]},{"title":"React组件生命周期","date":"2017-04-24T04:45:09.000Z","path":"2017/04/24/React组件生命周期/","text":"React 组件生命周期React组件的生命周期可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM componentWillMount 在渲染前调用,在客户端也在服务端。 componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用。 总结生命周期的回调函数 生命周期 调用次数 能否使用setSate() getDefaultProps 1(全局调用一次) 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 1 否","tags":[]},{"title":"React表单组件","date":"2017-04-21T04:45:55.000Z","path":"2017/04/21/React表单组件/","text":"1、像是input、textarea、option这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。2、交互属性表单组件支持几个受用户交互影响的属性value，用于input、textarea组件；checked，用于类型为checkbox或者radio的input组件；selected，用于option组件。在HTML中，textarea的值通过子节点设置，在React中则应该使用value代替。表单组件可以通过onChange会调函数来监听组件变化。当用户做出以下交互时，onChange执行并通过浏览器做出响应： input 或 textarea 的 value 发生变化时。 input 的 checked 状态改变时。 option 的 selected 状态改变时。 和所有的DOM事件一样，所有的HTML原生组件都支持onChange属性，而且可以用来监听冒泡的change事件。","tags":[{"name":"React表单","slug":"React表单","permalink":"http://yoursite.com/tags/React表单/"}]},{"title":"React历程","date":"2017-04-20T04:44:08.000Z","path":"2017/04/20/React历程/","text":"React介绍1、React 是一个用于构建用户界面的 JAVASCRIPT 库。2、React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。3、React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。4、React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React的特点1、声明式设计 −React采用声明范式，可以轻松描述应用。2、高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3、灵活 −React可以与已知的库或框架很好地配合。4、JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5、组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6、单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React组件API1、SetState:设置状态2、replaceState:替换状态3、setProps:设置属性4、replaceProps:替换属性5、forceUpdate:强制更新6、findDomNode:获取DOM节点7、isMounted:判断组件挂载状态 Tip 原生HTML元素名以小写字母开头，而自定义的React类名以大写字母开头，还需注意组件类只能包含一个顶层标签。 React只需更新组件的state,然后根据新的state重新渲染用户界面。","tags":[]},{"title":"Hello World","date":"2017-04-18T05:46:33.000Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]