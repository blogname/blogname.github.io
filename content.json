[{"title":"Vue旅行小账本 第一版","date":"2018-09-03T08:55:08.000Z","path":"2018/09/03/Vue旅行小账本/","text":"Vue旅行小账本闲来无事，学习了一段时间的Vue，顺带着把axios vuex vue-router也整体走了一遍，但是一直苦于没有合适的练手项目，直到最近看到微信小程序版的旅行小账本，才发现这个项目才是我一直寻找的。话不多说，直接进入主题。 前期准备，首先大体上看了一遍小程序版的旅行小账本的页面和基本交互，大致确定了技术方案因为页面结构简单，所以没有使用vue的ui库，选取了vue-cli进行开发，vue-cli进行rem适配和其他的一些细节，这里我就不再多讲了，大家有兴趣可以看我另一篇博文。Vue将px转化为rem在数据获取方面，选取了很火的axios，因为没有后台程序，所以数据接口暂时用easy-mock来进行模拟，数据的存储，没有后台接口可用，暂时使用vuex进行存储。 easy-mock进行数据模拟 easy-mock可用很简单地模拟和管理接口非常方便，就拿我们的启动页来说吧 我这里的大致方案是，在路由里进行配置，当项目初始化时，进入启动页面，再由启动页面设置定时器，到时间跳转到首页，下面是具体方案和优化 页面路由的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Vue from 'vue'import Router from 'vue-router'const Index = resolve =&gt; require(['view/index/index'], resolve)const startUp = resolve =&gt; require(['view/start-up/start-up'], resolve)const addTravelInfo = resolve =&gt; require(['view/add-travel-info/add-travel-info'], resolve)const chioceTravelBg = resolve =&gt; require(['view/chioce-travel-bg/chioce-travel-bg'], resolve)const travelInfo = resolve =&gt; require(['view/travel-info/travel-info'], resolve)const travelPayInfo = resolve =&gt; require(['view/travel-pay-info/travel-pay-info'], resolve)Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', redirect: '/startUp' &#125;, &#123; path: '/startUp', // 启动页面只显示5秒 name: 'startUp', component: startUp &#125;, &#123; path: '/Index', // 首页入口 name: 'Index', component: Index &#125;, &#123; path: '/addTravelInfo', // 添加旅行账单页面 name: 'addTravelInfo', component: addTravelInfo &#125;, &#123; path: '/chioceTravelBg', // 选择背景图片 name:'chioceTravelBg', component: chioceTravelBg &#125;, &#123; path:'/travelInfo/:id', //详情页面 name:'travelInfo', component:travelInfo &#125;, &#123; path:'/travelPayInfo', //新增开支页面 name:'travelPayInfo', component:travelPayInfo &#125; ]&#125;) 在进入页面时我们需要进行数据的获取，使用axios进行了简单的封装，获取easy mock的接口数据，这里只是一个简单的数据获取与展示，easy mock的本质就是随机的数据，刚好页面启动页每次需要获取的数据都是随机的，所以使用起来很方便。下面这里是easy mock数据格式的写法，模拟随机返回一个对象123456789101112131415161718192021222324252627282930313233343536&#123; \"data\": &#123; 'status': 200, 'image|1': [&#123; 'imgUrl': 'static/start-up-1.jpg', 'imgAlt': '悬崖大海', 'imgAuthor': '学涯' &#125;, &#123; 'imgUrl': 'static/start-up-2.jpg', 'imgAlt': '远方的旅行', 'imgAuthor': '桃花' &#125;, &#123; 'imgUrl': 'static/start-up-3.jpg', 'imgAlt': '朦胧乡村', 'imgAuthor': '季青' &#125;, &#123; 'imgUrl': 'static/start-up-4.jpg', 'imgAlt': '心中的旅行', 'imgAuthor': '薛慧' &#125;, &#123; 'imgUrl': 'static/start-up-5.jpg', 'imgAlt': '心中的孤岛', 'imgAuthor': '忘记' &#125;, &#123; 'imgUrl': 'static/start-up-6.jpg', 'imgAlt': '宁静的古堡', 'imgAuthor': '凌燕' &#125; ] &#125;&#125; ###优化接口数据渲染方面进行了基本的优化，easy mock的数据请求速度比较慢，很容易由于页面在渲染时图片链接暂时没有，导致图片盒子在页面上有一条边框，不是很美观，所以这里进行了判断，如果链接请求不回来的话，不让img标签显示。 启动页面跳转到首页，前期也是由于，考虑到请求接口时，网络状况不太好，如果一进入页面就执行定时器，那么很有可能，页面上的图片还没加载出来，就直接跳转到了首页，所以我们这里进行了优化处理，当数据请求成功以后，再执行定时器。","tags":[{"name":"Vue axios vuex vue-router","slug":"Vue-axios-vuex-vue-router","permalink":"http://yoursite.com/tags/Vue-axios-vuex-vue-router/"}]},{"title":"Vue:将px转化为rem","date":"2018-08-15T04:31:03.000Z","path":"2018/08/15/Vue-将px转化为rem/","text":"Vue:将px转化为rem1、下载lib-flexible1npm i lib-flexible --save 2、引入lib-flexible在main.js中引入lib-flexible1import 'lib-flexible/flexible' 3、设置meta标签通过meta标签，设置设备宽度以及缩放比例1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 4、安装px2rem-loader1npm install px2rem-loader 5、配置px2rem-loader在build文件中找到util.js，将px2rem-loader添加到cssLoaders中1234567891011121314const cssLoader = &#123; loader: 'css-loader', options: &#123; minimize: process.env.NODE_ENV === 'production', sourceMap: options.sourceMap &#125; &#125; const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75 &#125; &#125;&#125; 同时，在generateLoaders方法中添加px2remLoader1234567891011function generateLoaders (loader, loaderOptions) &#123; const loaders = [cssLoader,px2remLoader] if (loader) &#123; loaders.push(&#123; loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125;&#125; 6、重启，一切ok~1npm run dev","tags":[{"name":"Vue px rem","slug":"Vue-px-rem","permalink":"http://yoursite.com/tags/Vue-px-rem/"}]},{"title":"React井字小游戏","date":"2017-07-05T07:24:25.000Z","path":"2017/07/05/React井字小游戏/","text":"React井字小游戏在React官方文档中，有一个很适合菜鸟练手的React项目，React井字小游戏。在这篇教程里，主要涉及到了es6的一些语法。 现在我们这里已经搭建好一个基本的游戏模板，你可以点击这里进行下载 首先来搭建React的基本运行环境1、首先需要你安装最新版的node2、点击创建新的React项目3、删除掉src文件夹下的所有文件4、在 src/ 文件夹下新建一个名为 index.css 的文件并拷贝 这里的 CSS 代码 到文件中。5、在 src/ 文件夹下新建一个名为 index.js 的文件并拷贝 这里的 JS 代码 到文件中, 并在此文件的最开头加上下面几行代码： 1234import React from 'react';import ReactDOM from 'react-dom';import './index.css'; 在完成上述操作以后，可以运行cmd进行依赖的安装，运行项目以后，点击http://localhost:3000/就可以看到这样的呈现效果 不过现在还没有添加功能，接下来给模板添加一些功能 12345678//棋盘上单独的一个格子function Square(props)&#123; return( &lt;button className=\"square\" onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125; props &amp;&amp; state props用于各个组件之间传递数据,state用于组件内部更新状态react推荐凡是组件通信数据都是通过props。他与state的区别在于，state是通过setState来更新的，props是通过组件的生命周期来更新的，这意味着，组件生命周期不发生变化，props是不会变的. 子组件Square上绑定的onClick事件是从父组件Board由props.onClick属性传递过来的 12345678910111213141516171819202122232425262728293031//棋盘主体class Board extends React.Component &#123;//这里渲染出每一个棋格 renderSquare(i) &#123; return &lt;Square value=&#123;this.props.squares[i]&#125; onClick=&#123;()=&gt;this.props.onClick(i)&#125; /&gt;; &#125; render() &#123; return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; Game组件里编写了我们小游戏的基本逻辑，在这里要阐述一下React的状态提升，以及它的必要性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Game 组件则为我们即将要编写的代码预留了一些位置class Game extends React.Component &#123;//保存初始化状态 constructor()&#123; super(); this.state=&#123; history:[&#123; squares:Array(9).fill(null), &#125;], stepNumber:0, xIsNext:true, &#125; &#125; handleClick(i)&#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current=history[history.length-1]; const squares=current.squares.slice(); //const squares=this.state.squares.slice();//.slice()方法将之前的数组数据深拷贝到一个新的数组中 if(calculateWinner(squares)||squares[i])&#123; return; &#125; squares[i]=this.state.xIsNext?'X':'O'; this.setState(&#123; history:history.concat([&#123; squares:squares &#125;]), stepNumber: history.length, xIsNext:!this.state.xIsNext, &#125;); &#125; jumpTo(step) &#123; this.setState(&#123; stepNumber: step, xIsNext: (step % 2) ? false : true, &#125;); &#125; render() &#123; const history =this.state.history.slice(0,this.state.stepNumber+1); const current =history[this.state.stepNumber]; const winner =calculateWinner(current.squares); const moves=history.map((step,move)=&gt;&#123; const desc=move? 'Move #'+move: 'Game start'; return( &lt;li key=&#123;move&#125;&gt; &lt;a href=\"#\" onClick=&#123;()=&gt;this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; ) &#125;); let status; if(winner)&#123; status=\"Winner:\"+winner; &#125;else&#123; status=\"Next player:\"+(this.state.xIsNext?'X':'O') &#125; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares=&#123;current.squares&#125; onClick=&#123;(i)=&gt;this.handleClick(i)&#125;/&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过props 将状态数据传递到子组件当中。这样应用当中的状态数据就能够更方便地交流共享了。在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。 在 React 组件的构造方法 constructor 当中，你可以通过 this.state 为该组件设置自身的状态数据。试着把棋盘格子变化的数据储存在组件的state 当中： 1234567891011//es6中的语法，把组件中的初始化状态，保存在constructor中constructor()&#123; super(); this.state=&#123; history:[&#123; squares:Array(9).fill(null), &#125;], stepNumber:0, xIsNext:true, &#125; &#125; 在constructor中存储了状态数据 handleClick用户操作的基本方法都由这里进行挂载派发，传递，然后子组件由props进行接收 123456789101112131415161718192021handleClick(i)&#123; //这里保存着棋盘的状态历史 const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length-1]; const squares = current.squares.slice(); //const squares=this.state.squares.slice();//.slice()方法将之前的数组数据深拷贝到一个新的数组中 if(calculateWinner(squares)||squares[i])&#123; return; &#125; squares[i]=this.state.xIsNext?'X':'O'; this.setState(&#123; history:history.concat([&#123; squares:squares &#125;]), stepNumber: history.length, xIsNext:!this.state.xIsNext, &#125;); &#125;","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"node第二天","date":"2017-07-04T08:12:32.000Z","path":"2017/07/04/node第二天/","text":"package.json的作用在这里我们要引入utility，需要在package.json中进行配置 app.js中代码如下1234567891011121314151617//引入依赖var express = require('express');var utility = require('utility');var app = express();app.get('/', function (req, res) &#123;//获得请求头部 var q = req.query.q; //使用md5进行加密 var md5Value = utility.md5(q); res.send(md5Value);&#125;);app.listen(3000, function (req, res) &#123; console.log('app is running at port 3000');&#125;); 这里我们在cmd中运行app.js，但是这次不同的地方在于，我们访问的网页地址需要作出一些变化访问 http://localhost:3000/?q=alsotang 完成结果如下 题外话如果直接访问 http://localhost:3000/ 会抛错 可以看到，这个错误是从 crypto.js 中抛出的。 这是因为，当我们不传入 q 参数时，req.query.q 取到的值是 undefined，utility.md5 直接使用了这个空值，导致下层的 crypto 抛错。","tags":[{"name":"node utility","slug":"node-utility","permalink":"http://yoursite.com/tags/node-utility/"}]},{"title":"node第一天","date":"2017-07-04T07:51:19.000Z","path":"2017/07/04/node第一天/","text":"《搭建 Node.js 开发环境》其实这过程特别简单: node的版本管理工具，可以用来安装、切换node的版本， 先安装一个 nvm（ https://github.com/creationix/nvm ）1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。 安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试 1$ nvm 当看到有输出时，则 nvm 安装成功。 安装 Node.js使用 nvm 的命令安装 Node.js 最新稳定版，现在是 v0.12.3。 1$ nvm install 0.12 安装完成后，查看一下 1$ nvm ls 这时候可以看到自己安装的所有 Node.js 版本，输出应如下： （图1） 那个绿色小箭头的意思就是现在正在使用的版本，我这里是 v0.10.29。我还安装了 v0.11.14，但它并非我当前使用的版本。 如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 0.12.x 版本 1$ nvm use 0.12 然后再次查看，这时候小箭头应该出现了。 OK，我们在终端中输入 1$ node REPL(read–eval–print loop) 应该就出来了，那我们就成功了。 随便敲两行命令玩玩吧。 比如 &gt; while (true) {}，这时你的 CPU 应该会飚高。 完善安装上述过程完成后，有时会出现，当开启一个新的 shell 窗口时，找不到 node 命令的情况。 这种情况一般来自两个原因 一、shell 不知道 nvm 的存在 二、nvm 已经存在，但是没有 default 的 Node.js 版本可用。 解决方式： 一、检查 ~/.profile 或者 ~/.bash_profile 中有没有这样两句 12export NVM_DIR=&quot;/Users/YOURUSERNAME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 没有的话，加进去。 这两句会在 bash 启动的时候被调用，然后注册 nvm 命令。 二、 调用 $ nvm ls 看看像不像上述图1中一样，有 default 的指向。 如果没有的话，执行 $ nvm alias default 0.12 再 $ nvm ls 看一下 Hello World首先创建一个js文件，这里我命名为app.js 1234567891011var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 1234567891011121314151617// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。var express = require('express');// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。var app = express();// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 然后打开cmd 运行app.js文件我们可以看到 在浏览器中显示的内容","tags":[{"name":"node nvm","slug":"node-nvm","permalink":"http://yoursite.com/tags/node-nvm/"}]},{"title":"sass语法","date":"2017-05-19T02:53:44.000Z","path":"2017/05/19/sass语法/","text":"SASS语法（上） 学过CSS的人都知道，它不是一种编程语言。 你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。 很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。 下面是我整理的sass用法总结。 文件后缀名sass有两种后缀名文件：一种后缀名为sass，不使用大括号和分号；另一种就是我们这里使用的scss文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。而本教程中所说的所有sass文件都指后缀名为scss的文件。在此也建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。 123456789101112131415//文件后缀名为sass的语法body background: #eee font-size:12pxp background: #0982c1//文件后缀名为scss的语法body &#123; background: #eee; font-size:12px;&#125;p&#123; background: #0982c1;&#125; 导入sass的导入(@import)规则和CSS的有所不同，编译时会将@import的scss文件合并进来只生成一个CSS文件。但是如果你在sass文件中导入css文件如@import ‘reset.css’，那效果跟普通CSS导入样式文件一样，导入的css文件不会合并到编译后的文件中，而是以@import方式存在。所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import “mixin”。被导入sass文件a.scss：12345//a.scss//-------------------------------body &#123; background: #eee;&#125; 需要导入样式的sass文件b.scss：12345@import \"reset.css\";@import \"a\";p&#123; background: #0982c1;&#125; 转译出来的b.css样式：1234567@import \"reset.css\";body &#123; background: #eee;&#125;p&#123; background: #0982c1;&#125; 根据上面的代码可以看出，b.scss编译后，reset.css继续保持import的方式，而a.scss则被整合进来了。 变量sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样），如果值后面加上!default则表示默认值。普通变量定义之后可以在全局范围内使用。123456789101112//sass style//-------------------------------$fontSize: 12px;body&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:12px;&#125; 默认变量sass的默认变量仅需要在值后面加上!default即可。123456789101112//sass style//-------------------------------$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight;&#125;//css style//-------------------------------body&#123; line-height:1.5;&#125; sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可12345678910111213//sass style//-------------------------------$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight;&#125;//css style//-------------------------------body&#123; line-height:2;&#125; 可以看出现在编译后的line-height为2，而不是我们默认的1.5。默认变量的价值在进行组件化开发的时候会非常有用。特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用。1234567891011121314151617181920212223//sass style//-------------------------------$borderDirection: top !default;$baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;//应用于复杂的属性值body&#123; font:#&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style//-------------------------------.border-top&#123; border-top:1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 多值变量多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。listlist数据可通过空格，逗号或小括号分隔多个值，可用nth($var,$index)取值。关于list数据操作还有很多其他函数如length($list)，join($list1,$list2,[$separator])，append($list,$value,[$separator])等定义123456//一维数据$px: 5px 10px 20px 30px;//二维数据，相当于js中的二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px); 使用12345678910111213141516171819//sass style//-------------------------------$linkColor: #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;//css style//-------------------------------a&#123; color:#08c;&#125;a:hover&#123; color:#333;&#125; mapmap数据以key和value成对出现，其中value又可以是list。格式为：$map: (key1: value1, key2: value2, key3: value3);。可通过map-get($map,$key)取值。关于map数据还有很多其他函数如map-merge($map1,$map2)，map-keys($map)，map-values($map)等，具体可参考sass Functions（搜索Map Functions即可）定义1$heading: (h1: 2em, h2: 1.5em, h3: 1.2em); 使用1234567891011121314151617181920//sass style//-------------------------------$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css style//-------------------------------h1 &#123; font-size: 2em;&#125;h2 &#123; font-size: 1.5em;&#125;h3 &#123; font-size: 1.2em;&#125; 全局变量在变量值后面加上!global即为全局变量。这个目前还用不上，不过将会在sass 3.4后的版本中正式应用。目前的sass变量范围饱受诟病，所以才有了这个全局变量。目前变量机制在选择器中声明的变量会覆盖外面全局声明的变量。(这也就人们常说的sass没有局部变量)12345678910111213141516171819//sass style//-------------------------------$fontSize: 12px;body&#123; $fontSize: 14px; font-size:$fontSize;&#125;p&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:14px;&#125;p&#123; font-size:14px;&#125; 启用global之后的机制请注意，这个目前还无法使用，所以样式不是真实解析出来的。12345678910111213141516171819202122232425//sass style//-------------------------------$fontSize: 12px;$color: #333;body&#123; $fontSize: 14px; $color： #fff !global; font-size:$fontSize; color:$color;&#125;p&#123; font-size:$fontSize; color:$color;&#125;//css style//-------------------------------body&#123; font-size:14px; color:#fff;&#125;p&#123; font-size:12px; color:#fff;&#125; 这里设置了两个变量，然后在body里面重新设置了下，有点不同的是对于$color变量，我们设置了!global。通过编译后的css可以看到font-size取值不同，而color取值相同。与上面的机制对比就会发现默认在选择器里面的变量为局部变量，而只有设置了!global之后才会成为全局变量。","tags":[]},{"title":"React Router","date":"2017-05-12T05:46:33.000Z","path":"2017/05/12/React Router/","text":"1、React Router的作用 一、React Router解决了React components 到URl之间的同步映射关系 二、Route组件定义了URL路径与组件的对应关系 三、路由器Router其实就是React的一个组件，在使用的时候，直接引用。 下面举一个例子，在没有使用React Router时，我们的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243var About = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;About&lt;/h2&gt;; &#125;&#125;);var Inbox = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;Inbox&lt;/h2&gt;; &#125;&#125;);var Home = React.createClass(&#123; render: function () &#123; return &lt;h2&gt;Home&lt;/h2&gt;; &#125;&#125;);var App = React.createClass(&#123; render () &#123; var Child; switch (this.props.route) &#123; case 'about': Child = About; break; case 'inbox': Child = Inbox; break; default: Child = Home; &#125; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;Child/&gt; &lt;/div&gt; ) &#125;&#125;);function render () &#123; var route = window.location.hash.substr(1); React.render(&lt;App route=&#123;route&#125; /&gt;, document.body);&#125;window.addEventListener('hashchange', render);render(); // render initially 一、在hash值改变的时候，App 将会根据this.props.route值的改变来动态渲染 component。 二、这样的做法虽然看起来很直接，但是会导致整个应用程序变得更加复杂。比如，如果组件 Inbox 有一些内嵌的子组件需要根据 例如 inbox/message/:id 或者 inbox/unread 等这样的路由规则做动态渲染的时候。我们需要一些更加智能的手段来把路由信息传递给我们的App，这样Inbox 组件可以根据URL的映射关系来控制哪些子组件应该需要被渲染。 三、很多组件应该根据URL的规则来做动态渲染。在不使用路由规则的前提下，复杂一点的路由需求就需要我们写很多条件判断的代码去去解决实RL和层级组件的同步问题。 引入React Router 123456789101112131415161718192021222324252627282930313233343536373839404142var Router = require('react-router'); var Route = Router.Route; // declare our routes and their hierarchy var routes = ( &lt;Route handler=&#123;App&#125;&gt; &lt;Route path=\"about\" handler=&#123;About&#125;/&gt; &lt;Route path=\"inbox\" handler=&#123;Inbox&#125;/&gt; &lt;/Route&gt; ); var RouteHandler = Router.RouteHandler; var App = React.createClass(&#123; render () &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RouteHandler/&gt; &lt;/div&gt; ) &#125; &#125;); Router.run(routes, Router.HashLocation, (Root) =&gt; &#123; React.render(&lt;Root/&gt;, document.body); &#125;); var Message = React.createClass(&#123; render () &#123; return &lt;h3&gt;Message&lt;/h3&gt;; &#125; &#125;); var routes = ( &lt;Route handler=&#123;App&#125;&gt; &lt;Route path=\"about\" handler=&#123;About&#125;/&gt; &lt;Route path=\"inbox\" handler=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" handler=&#123;Message&#125;/&gt; &lt;/Route&gt; &lt;/Route&gt; ); 一、Root 是 React Router 路由匹配后决定渲染的最高层级的组件，告诉 RouterHandle 应该渲染的内容是什么。 组件是不会被渲染的。只是一个创建内部路由规则的配置对象。 二、解决复杂的URL和层级组件之间的映射关系式React Router 的核心。 三、使用声明式的方式为举的例子引入路由。使用JSX的方式来进行路由的配置，这样就可以通过属性的方式来配置页面视图的层级关系。 2、Redirect 组件 1234&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125; ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt; &lt;/Route&gt; 一、Redirect组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。 二、{/ 从 /inbox/messages/:id 跳转到 /messages/:id /}","tags":[]},{"title":"React练习Todolist","date":"2017-05-08T05:42:10.000Z","path":"2017/05/08/React练习Todolist/","text":"todolist页面效果 基本功能 1、用户可以添加任务，当用户输入的内容为空时，不添加。 2、用户可以随时切换任务的完成状态，并进行显示提示已完成数量与总任务数量 3、用户可以删除列表中的任一任务。Demo地址：查看Demo地址 创建React组件 创建TodoBox组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var TodoBox = React.createClass(&#123; getInitialState: function() &#123; return &#123; data: [ &#123;\"id\": \"0001\", \"task\":\"吃饭\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0002\", \"task\":\"睡觉\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0003\", \"task\":\"打豆豆\", \"complete\": \"true\"&#125; ] &#125;; &#125;, // 根据id删除一项任务 handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;); &#125;, // 切换一项任务的完成状态 handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;); &#125;, // 给新增的任务一个随机的id generateId: function() &#123; return Math.floor(Math.random() * 9000) + 1000; &#125;, // 新增一项任务 handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//链接两个对象 this.setState(&#123;data&#125;); &#125;, render: function() &#123; var statistics = &#123; // 统计任务总数及完成的数量 todoCount: this.state.data.length || 0, todoCompleteCount: this.state.data.filter(function(item) &#123; return item.complete === \"true\"; &#125;).length &#125;; return ( &lt;div className=\"well\"&gt; &lt;h1 className=\"text-center\"&gt;React Todo&lt;/h1&gt; &lt;TodoList data=&#123;this.state.data&#125; deleteTask=&#123;this.handleTaskDelete&#125; toggleComplete=&#123;this.handleToggleComplete&#125; todoCount=&#123;statistics.todoCount&#125; todoCompleteCount=&#123;statistics.todoCompleteCount&#125; /&gt; &lt;TodoForm submitTask=&#123;this.handleSubmit&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); 1、获取当前组件的初始化状态，在TodoBox组件中，定义该组件所要使用的方法。 2、删除该项任务的功能：根据Id删除一项任务，首先获取该组件在删除任务之前的所有任务列表，根据传入的id进行过滤判断，返回其他项任务，进行删除传入id的任务项。更新当前状态值。 1234567handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;);&#125;, 3、切换任务的完成状态功能：传入的值仍为任务当前的Id值，先获取初始数据进行遍历，判断当前任务的complete属性值是什么，使用三元表达式进行判断转换，如：初始值为true，就转换成false，反之亦然。更新当前状态值。 12345678910handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;);&#125;, 4、添加任务功能：设定该任务项的基本属性（id，task,complete）,并与之前获得的状态任务列表进行合并并更新当前状态值。 1234567handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//连接两个对象 this.setState(&#123;data&#125;); &#125;, 创建TodoList组件12345678910111213141516171819202122var TodoList = React.createClass(&#123; render: function() &#123; var taskList = this.props.data.map(function(listItem) &#123; return ( &lt;TodoItem taskId=&#123;listItem.id&#125; key=&#123;listItem.id&#125; task=&#123;listItem.task&#125; complete=&#123;listItem.complete&#125; deleteTask=&#123;this.props.deleteTask&#125; toggleComplete=&#123;this.props.toggleComplete&#125; /&gt; ) &#125;, this); return ( &lt;ul className=\"list-group\"&gt; &#123;taskList&#125; &lt;TodoFooter todoCount=&#123;this.props.todoCount&#125; todoCompleteCount=&#123;this.props.todoCompleteCount&#125; /&gt; &lt;/ul&gt; ); &#125;&#125;); 1、这里介绍一下React中的props与state的区别state作用 更新组件的state，会导致用户界面的重新渲染（不用操作DOM）,直白来说就是用户的界面会跟着state的变化而变化。props作用 是一种父级向子级传递数据的方式，也就是说从拥有者流向归属者。这里this.props.data.map()组件从父级获取数据并进行遍历。 创建TodoItem组件12345678910111213141516171819202122232425262728293031323334353637383940414243var TodoItem = React.createClass(&#123; toggleComplete: function() &#123; this.props.toggleComplete(this.props.taskId); &#125;, deleteTask: function() &#123; this.props.deleteTask(this.props.taskId); &#125;, // 鼠标移入显示删除按钮 handleMouseOver: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"inline\"; &#125;, handleMouseOut: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"none\"; &#125;, render: function() &#123; var task = this.props.task; var classes = \"list-group-item\"; var itemChecked; if (this.props.complete === \"true\") &#123; task = &lt;s&gt;&#123;task&#125;&lt;/s&gt;; itemChecked = true; classes += \" list-group-item-success\" &#125; else &#123; itemChecked = false; &#125; return ( &lt;li className=&#123;classes&#125; onMouseOver=&#123;this.handleMouseOver&#125; onMouseOut=&#123;this.handleMouseOut&#125;&gt; &lt;input type=\"checkbox\" checked=&#123;itemChecked&#125; onChange=&#123;this.toggleComplete&#125; className=\"pull-left\" /&gt; &#123;task&#125; &lt;div className=\"pull-right\"&gt; &lt;button type=\"button\" className=\"btn btn-xs close\" onClick=&#123;this.deleteTask&#125; ref=\"deleteBtn\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ); &#125;&#125;); 1、要介绍ref属性，首先得介绍一下render()特别注意的是：从 render() 返回来的不是你实际绘制的子组件的实例。从 render() 返回来的仅仅是一个特定的时刻在你组成部分的 sub-hierarchy 中的子组件实例的描述。所以，要想获得在TodoItem中render()里返回的删除按钮，需要在按钮本身上添加ref属性。 2、这里介绍一下React中的ref属性refs作用 React 支持一个非常特殊的属性，你可以附加到任何从 render() 输出的组件中。这个特殊的属性允许你涉及相应的任何从 render() 返回的支持实例。它总是保证成为适当的实例，在任何时候。 其余组件的创建12345678910111213141516171819202122232425262728293031323334353637383940var TodoFooter = React.createClass(&#123; render: function() &#123; return ( &lt;li className=\"list-group-item\"&gt;&#123;this.props.todoCompleteCount&#125;已完成 / &#123;this.props.todoCount&#125;总数&lt;/li&gt; ) &#125;&#125;);var TodoForm = React.createClass(&#123; submitTask: function(e) &#123; e.preventDefault(); var task = ReactDOM.findDOMNode(this.refs.task).value.trim(); if (!task) &#123; return; &#125; this.props.submitTask(task); ReactDOM.findDOMNode(this.refs.task).value = \"\"; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;hr /&gt; &lt;form className=\"form-horizontal\" onSubmit=&#123;this.submitTask&#125;&gt; &lt;div className=\"form-group\"&gt; &lt;label for=\"task\" className=\"col-md-2 control-label\"&gt;Task&lt;/label&gt; &lt;div className=\"col-md-10\"&gt; &lt;input type=\"text\" id=\"task\" ref=\"task\" className=\"form-control\" placeholder=\"你想做点什么\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"row\"&gt; &lt;div className=\"col-md-12 text-right\"&gt; &lt;input type=\"submit\" value=\"Save Task\" className=\"btn btn-primary\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125;); 心得总结 刚开始使用React做简单的案例，总感觉没有了以前的DOM操作，很不适应，尤其是React中的JSX语法糖中html与js混合编写，真的是感觉很不适应。但是当真正做完一两个项目以后， 才发现React组件化的思想对于后续代码的管理和维护，以及编程前的思维逻辑方便了很多，自己在React的道路上才刚刚开始，希望在探索React的道路上，努力前行！！！","tags":[]},{"title":"Demo练习","date":"2017-04-25T04:46:36.000Z","path":"2017/04/25/Demo练习/","text":"用户评论功能 用户可以发表评论，使用React组件化 在github上还有功能扩展，从后台读取数据，渲染到列表下方 用户输入的实时评论也可以写入后台服务器 Demo地址：查看Demo地址","tags":[]},{"title":"React组件生命周期","date":"2017-04-24T04:45:09.000Z","path":"2017/04/24/React组件生命周期/","text":"React 组件生命周期React组件的生命周期可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM componentWillMount 在渲染前调用,在客户端也在服务端。 componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用。 总结生命周期的回调函数 生命周期 调用次数 能否使用setSate() getDefaultProps 1(全局调用一次) 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 1 否","tags":[]},{"title":"React表单组件","date":"2017-04-21T04:45:55.000Z","path":"2017/04/21/React表单组件/","text":"1、像是input、textarea、option这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。2、交互属性表单组件支持几个受用户交互影响的属性value，用于input、textarea组件；checked，用于类型为checkbox或者radio的input组件；selected，用于option组件。在HTML中，textarea的值通过子节点设置，在React中则应该使用value代替。表单组件可以通过onChange会调函数来监听组件变化。当用户做出以下交互时，onChange执行并通过浏览器做出响应： input 或 textarea 的 value 发生变化时。 input 的 checked 状态改变时。 option 的 selected 状态改变时。 和所有的DOM事件一样，所有的HTML原生组件都支持onChange属性，而且可以用来监听冒泡的change事件。","tags":[{"name":"React表单","slug":"React表单","permalink":"http://yoursite.com/tags/React表单/"}]},{"title":"React历程","date":"2017-04-20T04:44:08.000Z","path":"2017/04/20/React历程/","text":"React介绍1、React 是一个用于构建用户界面的 JAVASCRIPT 库。2、React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。3、React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。4、React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React的特点1、声明式设计 −React采用声明范式，可以轻松描述应用。2、高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3、灵活 −React可以与已知的库或框架很好地配合。4、JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5、组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6、单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React组件API1、SetState:设置状态2、replaceState:替换状态3、setProps:设置属性4、replaceProps:替换属性5、forceUpdate:强制更新6、findDomNode:获取DOM节点7、isMounted:判断组件挂载状态 Tip 原生HTML元素名以小写字母开头，而自定义的React类名以大写字母开头，还需注意组件类只能包含一个顶层标签。 React只需更新组件的state,然后根据新的state重新渲染用户界面。","tags":[]},{"title":"Hello World","date":"2017-04-18T05:46:33.000Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]