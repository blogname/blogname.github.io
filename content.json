[{"title":"React练习Todolist","date":"2017-05-08T05:42:10.000Z","path":"2017/05/08/React练习Todolist/","text":"todolist页面效果 基本功能 1、用户可以添加任务，当用户输入的内容为空时，不添加。 2、用户可以随时切换任务的完成状态，并进行显示提示已完成数量与总任务数量 3、用户可以删除列表中的任一任务。Demo地址：查看Demo地址 创建React组件 创建TodoBox组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var TodoBox = React.createClass(&#123; getInitialState: function() &#123; return &#123; data: [ &#123;\"id\": \"0001\", \"task\":\"吃饭\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0002\", \"task\":\"睡觉\", \"complete\": \"false\"&#125;, &#123;\"id\": \"0003\", \"task\":\"打豆豆\", \"complete\": \"true\"&#125; ] &#125;; &#125;, // 根据id删除一项任务 handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;); &#125;, // 切换一项任务的完成状态 handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;); &#125;, // 给新增的任务一个随机的id generateId: function() &#123; return Math.floor(Math.random() * 9000) + 1000; &#125;, // 新增一项任务 handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//链接两个对象 this.setState(&#123;data&#125;); &#125;, render: function() &#123; var statistics = &#123; // 统计任务总数及完成的数量 todoCount: this.state.data.length || 0, todoCompleteCount: this.state.data.filter(function(item) &#123; return item.complete === \"true\"; &#125;).length &#125;; return ( &lt;div className=\"well\"&gt; &lt;h1 className=\"text-center\"&gt;React Todo&lt;/h1&gt; &lt;TodoList data=&#123;this.state.data&#125; deleteTask=&#123;this.handleTaskDelete&#125; toggleComplete=&#123;this.handleToggleComplete&#125; todoCount=&#123;statistics.todoCount&#125; todoCompleteCount=&#123;statistics.todoCompleteCount&#125; /&gt; &lt;TodoForm submitTask=&#123;this.handleSubmit&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); 1、获取当前组件的初始化状态，在TodoBox组件中，定义该组件所要使用的方法。 2、删除该项任务的功能：根据Id删除一项任务，首先获取该组件在删除任务之前的所有任务列表，根据传入的id进行过滤判断，返回其他项任务，进行删除传入id的任务项。更新当前状态值。 1234567handleTaskDelete: function(taskId) &#123; var data = this.state.data; data = data.filter(function(task) &#123; return task.id !== taskId; &#125;); this.setState(&#123;data&#125;);&#125;, 3、切换任务的完成状态功能：传入的值仍为任务当前的Id值，先获取初始数据进行遍历，判断当前任务的complete属性值是什么，使用三元表达式进行判断转换，如：初始值为true，就转换成false，反之亦然。更新当前状态值。 12345678910handleToggleComplete: function(taksId) &#123; var data = this.state.data; for(var i in data) &#123; if (data[i].id === taksId) &#123; data[i].complete = data[i].complete === \"true\" ? \"false\" : \"true\"; break; &#125; &#125; this.setState(&#123;data&#125;);&#125;, 4、添加任务功能：设定该任务项的基本属性（id，task,complete）,并与之前获得的状态任务列表进行合并并更新当前状态值。 1234567handleSubmit: function(task) &#123; var data = this.state.data; var id = this.generateId(); var complete = \"false\"; data = data.concat([&#123;\"id\": id, \"task\": task, \"complete\": \"false\"&#125;]);//连接两个对象 this.setState(&#123;data&#125;); &#125;, 创建TodoList组件12345678910111213141516171819202122var TodoList = React.createClass(&#123; render: function() &#123; var taskList = this.props.data.map(function(listItem) &#123; return ( &lt;TodoItem taskId=&#123;listItem.id&#125; key=&#123;listItem.id&#125; task=&#123;listItem.task&#125; complete=&#123;listItem.complete&#125; deleteTask=&#123;this.props.deleteTask&#125; toggleComplete=&#123;this.props.toggleComplete&#125; /&gt; ) &#125;, this); return ( &lt;ul className=\"list-group\"&gt; &#123;taskList&#125; &lt;TodoFooter todoCount=&#123;this.props.todoCount&#125; todoCompleteCount=&#123;this.props.todoCompleteCount&#125; /&gt; &lt;/ul&gt; ); &#125;&#125;); 1、这里介绍一下React中的props与state的区别state作用 更新组件的state，会导致用户界面的重新渲染（不用操作DOM）,直白来说就是用户的界面会跟着state的变化而变化。props作用 是一种父级向子级传递数据的方式，也就是说从拥有者流向归属者。这里this.props.data.map()组件从父级获取数据并进行遍历。 创建TodoItem组件12345678910111213141516171819202122232425262728293031323334353637383940414243var TodoItem = React.createClass(&#123; toggleComplete: function() &#123; this.props.toggleComplete(this.props.taskId); &#125;, deleteTask: function() &#123; this.props.deleteTask(this.props.taskId); &#125;, // 鼠标移入显示删除按钮 handleMouseOver: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"inline\"; &#125;, handleMouseOut: function() &#123; ReactDOM.findDOMNode(this.refs.deleteBtn).style.display = \"none\"; &#125;, render: function() &#123; var task = this.props.task; var classes = \"list-group-item\"; var itemChecked; if (this.props.complete === \"true\") &#123; task = &lt;s&gt;&#123;task&#125;&lt;/s&gt;; itemChecked = true; classes += \" list-group-item-success\" &#125; else &#123; itemChecked = false; &#125; return ( &lt;li className=&#123;classes&#125; onMouseOver=&#123;this.handleMouseOver&#125; onMouseOut=&#123;this.handleMouseOut&#125;&gt; &lt;input type=\"checkbox\" checked=&#123;itemChecked&#125; onChange=&#123;this.toggleComplete&#125; className=\"pull-left\" /&gt; &#123;task&#125; &lt;div className=\"pull-right\"&gt; &lt;button type=\"button\" className=\"btn btn-xs close\" onClick=&#123;this.deleteTask&#125; ref=\"deleteBtn\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ); &#125;&#125;); 1、要介绍ref属性，首先得介绍一下render()特别注意的是：从 render() 返回来的不是你实际绘制的子组件的实例。从 render() 返回来的仅仅是一个特定的时刻在你组成部分的 sub-hierarchy 中的子组件实例的描述。所以，要想获得在TodoItem中render()里返回的删除按钮，需要在按钮本身上添加ref属性。 2、这里介绍一下React中的ref属性refs作用 React 支持一个非常特殊的属性，你可以附加到任何从 render() 输出的组件中。这个特殊的属性允许你涉及相应的任何从 render() 返回的支持实例。它总是保证成为适当的实例，在任何时候。 其余组件的创建12345678910111213141516171819202122232425262728293031323334353637383940var TodoFooter = React.createClass(&#123; render: function() &#123; return ( &lt;li className=\"list-group-item\"&gt;&#123;this.props.todoCompleteCount&#125;已完成 / &#123;this.props.todoCount&#125;总数&lt;/li&gt; ) &#125;&#125;);var TodoForm = React.createClass(&#123; submitTask: function(e) &#123; e.preventDefault(); var task = ReactDOM.findDOMNode(this.refs.task).value.trim(); if (!task) &#123; return; &#125; this.props.submitTask(task); ReactDOM.findDOMNode(this.refs.task).value = \"\"; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;hr /&gt; &lt;form className=\"form-horizontal\" onSubmit=&#123;this.submitTask&#125;&gt; &lt;div className=\"form-group\"&gt; &lt;label for=\"task\" className=\"col-md-2 control-label\"&gt;Task&lt;/label&gt; &lt;div className=\"col-md-10\"&gt; &lt;input type=\"text\" id=\"task\" ref=\"task\" className=\"form-control\" placeholder=\"你想做点什么\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"row\"&gt; &lt;div className=\"col-md-12 text-right\"&gt; &lt;input type=\"submit\" value=\"Save Task\" className=\"btn btn-primary\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125;); 心得总结 刚开始使用React做简单的案例，总感觉没有了以前的DOM操作，很不适应，尤其是React中的JSX语法糖中html与js混合编写，真的是感觉很不适应。但是当真正做完一两个项目以后， 才发现React组件化的思想对于后续代码的管理和维护，以及编程前的思维逻辑方便了很多，自己在React的道路上才刚刚开始，希望在探索React的道路上，努力前行！！！","tags":[]},{"title":"Demo练习","date":"2017-04-25T04:46:36.000Z","path":"2017/04/25/Demo练习/","text":"用户评论功能 用户可以发表评论，使用React组件化 在github上还有功能扩展，从后台读取数据，渲染到列表下方 用户输入的实时评论也可以写入后台服务器 Demo地址：查看Demo地址","tags":[]},{"title":"React表单组件","date":"2017-04-25T04:45:55.000Z","path":"2017/04/25/React表单组件/","text":"1、像是input、textarea、option这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。2、交互属性表单组件支持几个受用户交互影响的属性value，用于input、textarea组件；checked，用于类型为checkbox或者radio的input组件；selected，用于option组件。在HTML中，textarea的值通过子节点设置，在React中则应该使用value代替。表单组件可以通过onChange会调函数来监听组件变化。当用户做出以下交互时，onChange执行并通过浏览器做出响应： input 或 textarea 的 value 发生变化时。 input 的 checked 状态改变时。 option 的 selected 状态改变时。 和所有的DOM事件一样，所有的HTML原生组件都支持onChange属性，而且可以用来监听冒泡的change事件。","tags":[{"name":"React表单","slug":"React表单","permalink":"http://yoursite.com/tags/React表单/"}]},{"title":"React组件生命周期","date":"2017-04-25T04:45:09.000Z","path":"2017/04/25/React组件生命周期/","text":"React 组件生命周期React组件的生命周期可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM componentWillMount 在渲染前调用,在客户端也在服务端。 componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用。 总结生命周期的回调函数 生命周期 调用次数 能否使用setSate() getDefaultProps 1(全局调用一次) 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 1 否","tags":[]},{"title":"React历程","date":"2017-04-25T04:44:08.000Z","path":"2017/04/25/React历程/","text":"React介绍1、React 是一个用于构建用户界面的 JAVASCRIPT 库。2、React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。3、React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。4、React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React的特点1、声明式设计 −React采用声明范式，可以轻松描述应用。2、高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3、灵活 −React可以与已知的库或框架很好地配合。4、JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5、组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6、单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React组件API1、SetState:设置状态2、replaceState:替换状态3、setProps:设置属性4、replaceProps:替换属性5、forceUpdate:强制更新6、findDomNode:获取DOM节点7、isMounted:判断组件挂载状态 Tip 原生HTML元素名以小写字母开头，而自定义的React类名以大写字母开头，还需注意组件类只能包含一个顶层标签。 React只需更新组件的state,然后根据新的state重新渲染用户界面。","tags":[]},{"title":"Hello World","date":"2017-04-25T04:14:18.428Z","path":"2017/04/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]